(function(){Template.__define__("api",Package.handlebars.Handlebars.json_ast_to_func([["#",[[0,"better_markdown"]],["\n\n<h1 id=\"api\">The Meteor API</h1>\n\nYour JavaScript code can run in two environments: the *client* (browser), and\nthe *server* (a [Node.js](http://nodejs.org/) container on a server).  For each\nfunction in this API reference, we'll indicate if the function is available just\non the client, just on the server, or *Anywhere*.\n\n<h2 id=\"core\"><span>Meteor Core</span></h2>\n\n",["#",[[0,"with"],[0,"isClient"]],[[">","api_box"]]],"\n",["#",[[0,"with"],[0,"isServer"]],[[">","api_box"]]],"\n\n",["#",[[0,"note"]],["\n`Meteor.isServer` can be used to limit where code runs, but it does not\nprevent code from being sent to the client. Any sensitive code that you\ndon't want served to the client, such as code containing passwords or\nauthentication mechanisms, should be kept in the `server` directory.\n"]],"\n\n\n",["#",[[0,"with"],[0,"startup"]],[[">","api_box"]]],"\n\nOn a server, the function will run as soon as the server process is\nfinished starting. On a client, the function will run as soon as the DOM\nis ready.\n\nThe `startup` callbacks are called in the same order as the calls to\n`Meteor.startup` were made.\n\nOn a client, `startup` callbacks from packages will be called\nfirst, followed by `<body>` templates from your `.html` files,\nfollowed by your application code.\n\n    // On server startup, if the database is empty, create some initial data.\n    if (Meteor.isServer) {\n      Meteor.startup(function () {\n        if (Rooms.find().count() === 0) {\n          Rooms.insert({name: \"Initial room\"});\n        }\n      });\n    }\n\n",["#",[[0,"with"],[0,"absoluteUrl"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"settings"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"release"]],[[">","api_box"]]],"\n\n<h2 id=\"publishandsubscribe\"><span>Publish and subscribe</span></h2>\n\nThese functions control how Meteor servers publish sets of records and\nhow clients can subscribe to those sets.\n\n",["#",[[0,"with"],[0,"publish"]],[[">","api_box"]]],"\n\nTo publish records to clients, call `Meteor.publish` on the server with\ntwo parameters: the name of the record set, and a *publish function*\nthat Meteor will call each time a client subscribes to the name.\n\nPublish functions can return a\n[`Collection.Cursor`](#meteor_collection_cursor), in which case Meteor\nwill publish that cursor's documents. You can also return an array of\n`Collection.Cursor`s, in which case Meteor will publish all of the\ncursors.\n\n",["#",[[0,"warning"]],["\nIf you return multiple cursors in an array, they currently must all be from\ndifferent collections. We hope to lift this restriction in a future release.\n"]],"\n\n    // server: publish the rooms collection, minus secret info.\n    Meteor.publish(\"rooms\", function () {\n      return Rooms.find({}, {fields: {secretInfo: 0}});\n    });\n\n    // ... and publish secret info for rooms where the logged-in user\n    // is an admin. If the client subscribes to both streams, the records\n    // are merged together into the same documents in the Rooms collection.\n    Meteor.publish(\"adminSecretInfo\", function () {\n      return Rooms.find({admin: this.userId}, {fields: {secretInfo: 1}});\n    });\n\n    // publish dependent documents and simulate joins\n    Meteor.publish(\"roomAndMessages\", function (roomId) {\n      check(roomId, String);\n      return [\n        Rooms.find({_id: roomId}, {fields: {secretInfo: 0}}),\n        Messages.find({roomId: roomId})\n      ];\n    });\n\nOtherwise, the publish function should call the functions\n[`added`](#publish_added) (when a new document is added to the published record\nset), [`changed`](#publish_changed) (when some fields on a document in the\nrecord set are changed or cleared), and [`removed`](#publish_removed) (when\ndocuments are removed from the published record set) to inform subscribers about\ndocuments.  These methods are provided by `this` in your publish function.\n\n\n\n<!-- TODO discuss ready -->\n\nExample:\n\n    // server: publish the current size of a collection\n    Meteor.publish(\"counts-by-room\", function (roomId) {\n      var self = this;\n      check(roomId, String);\n      var count = 0;\n      var initializing = true;\n      var handle = Messages.find({roomId: roomId}).observeChanges({\n        added: function (id) {\n          count++;\n          if (!initializing)\n            self.changed(\"counts\", roomId, {count: count});\n        },\n        removed: function (id) {\n          count--;\n          self.changed(\"counts\", roomId, {count: count});\n        }\n        // don't care about moved or changed\n      });\n\n      // Observe only returns after the initial added callbacks have\n      // run.  Now return an initial value and mark the subscription\n      // as ready.\n      initializing = false;\n      self.added(\"counts\", roomId, {count: count});\n      self.ready();\n\n      // Stop observing the cursor when client unsubs.\n      // Stopping a subscription automatically takes\n      // care of sending the client any removed messages.\n      self.onStop(function () {\n        handle.stop();\n      });\n    });\n\n    // client: declare collection to hold count object\n    Counts = new Meteor.Collection(\"counts\");\n\n    // client: subscribe to the count for the current room\n    Deps.autorun(function () {\n      Meteor.subscribe(\"counts-by-room\", Session.get(\"roomId\"));\n    });\n\n    // client: use the new collection\n    console.log(\"Current room has \" +\n                Counts.findOne(Session.get(\"roomId\")).count +\n                \" messages.\");\n\n",["#",[[0,"warning"]],["\nMeteor will emit a warning message if you call `Meteor.publish` in a\nproject that includes the `autopublish` package.  Your publish function\nwill still work.\n"]],"\n\n",["#",[[0,"with"],[0,"subscription_userId"]],[[">","api_box"]]],"\n\nThis is constant. However, if the logged-in user changes, the publish\nfunction is rerun with the new value.\n\n",["#",[[0,"with"],[0,"subscription_added"]],[[">","api_box"]]],"\n",["#",[[0,"with"],[0,"subscription_changed"]],[[">","api_box"]]],"\n",["#",[[0,"with"],[0,"subscription_removed"]],[[">","api_box"]]],"\n",["#",[[0,"with"],[0,"subscription_ready"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"subscription_onStop"]],[[">","api_box"]]],"\n\nIf you call [`observe`](#observe) or [`observeChanges`](#observe_changes) in your\npublish handler, this is the place to stop the observes.\n\n",["#",[[0,"with"],[0,"subscription_error"]],[[">","api_box"]]],"\n",["#",[[0,"with"],[0,"subscription_stop"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"subscribe"]],[[">","api_box"]]],"\n\nWhen you subscribe to a record set, it tells the server to send records to the\nclient.  The client stores these records in local [Minimongo\ncollections](#meteor_collection), with the same name as the `collection`\nargument used in the publish handler's `added`, `changed`, and `removed`\ncallbacks.  Meteor will queue incoming attributes until you declare the\n[`Meteor.Collection`](#meteor_collection) on the client with the matching\ncollection name.\n\n    // okay to subscribe (and possibly receive data) before declaring\n    // the client collection that will hold it.  assume \"allplayers\"\n    // publishes data from server's \"players\" collection.\n    Meteor.subscribe(\"allplayers\");\n    ...\n    // client queues incoming players records until ...\n    ...\n    Players = new Meteor.Collection(\"players\");\n\nThe client will see a document if the document is currently in the published\nrecord set of any of its subscriptions.\n\nThe `onReady` callback is called with no arguments when the server\n[marks the subscription as ready](#publish_ready). The `onError` callback is\ncalled with a [`Meteor.Error`](#meteor_error) if the subscription fails or is\nterminated by the server.\n\n`Meteor.subscribe` returns a subscription handle, which is an object with the\nfollowing methods:\n\n<dl class=\"callbacks\">\n",["#",[[0,"dtdd"],"stop()"],["\nCancel the subscription. This will typically result in the server directing the\nclient to remove the subscription's data from the client's cache.\n"]],"\n\n",["#",[[0,"dtdd"],"ready()"],["\nTrue if the server has [marked the subscription as ready](#publish_ready). A\nreactive data source.\n"]],"\n</dl>\n\nIf you call `Meteor.subscribe` within a [reactive computation](#reactivity),\nfor example using\n[`Deps.autorun`](#deps_autorun), the subscription will automatically be\ncancelled when the computation is invalidated or stopped; it's not necessary\nto call `stop` on\nsubscriptions made from inside `autorun`. However, if the next iteration\nof your run function subscribes to the same record set (same name and\nparameters), Meteor is smart enough to skip a wasteful\nunsubscribe/resubscribe. For example:\n\n    Deps.autorun(function () {\n      Meteor.subscribe(\"chat\", {room: Session.get(\"current-room\")});\n      Meteor.subscribe(\"privateMessages\");\n    });\n\nThis subscribes you to the chat messages in the current room and to your private\nmessages. When you change rooms by calling `Session.set(\"current-room\",\n\"new-room\")`, Meteor will subscribe to the new room's chat messages,\nunsubscribe from the original room's chat messages, and continue to\nstay subscribed to your private messages.\n\nIf more than one subscription sends conflicting values for a field (same\ncollection name, document ID, and field name), then the value on the client will\nbe one of the published values, chosen arbitrarily.\n\n<h2 id=\"methods_header\"><span>Methods</span></h2>\n\nMethods are remote functions that Meteor clients can invoke.\n\n",["#",[[0,"with"],[0,"methods"]],[[">","api_box"]]],"\n\nExample:\n\n    Meteor.methods({\n      foo: function (arg1, arg2) {\n        check(arg1, String);\n        check(arg2, [Number]);\n        // .. do stuff ..\n        if (you want to throw an error)\n          throw new Meteor.Error(404, \"Can't find my pants\");\n        return \"some return value\";\n      },\n\n      bar: function () {\n        // .. do other stuff ..\n        return \"baz\";\n      }\n    });\n\nCalling `methods` on the server defines functions that can be called remotely by\nclients.  They should return an [EJSON](#ejson)-able value or throw an\nexception.  Inside your method invocation, `this` is bound to a method\ninvocation object, which provides the following:\n\n* `isSimulation`: a boolean value, true if this invocation is a stub.\n* `unblock`: when called, allows the next method from this client to\nbegin running.\n* `userId`: the id of the current user.\n* `setUserId`: a function that associates the current client with a user.\n\nCalling `methods` on the client defines *stub* functions associated with\nserver methods of the same name.  You don't have to define a stub for\nyour method if you don't want to.  In that case, method calls are just\nlike remote procedure calls in other systems, and you'll have to wait\nfor the results from the server.\n\nIf you do define a stub, when a client invokes a server method it will\nalso run its stub in parallel.  On the client, the return value of a\nstub is ignored.  Stubs are run for their side-effects: they are\nintended to *simulate* the result of what the server's method will do,\nbut without waiting for the round trip delay.  If a stub throws an\nexception it will be logged to the console.\n\nYou use methods all the time, because the database mutators\n([`insert`](#insert), [`update`](#update), [`remove`](#remove)) are implemented\nas methods. When you call any of these functions on the client, you're invoking\ntheir stub version that update the local cache, and sending the same write\nrequest to the server. When the server responds, the client updates the local\ncache with the writes that actually occurred on the server.\n\n",["#",[[0,"with"],[0,"method_invocation_userId"]],[[">","api_box"]]],"\n\nThe user id is an arbitrary string &mdash; typically the id of the user record\nin the database. You can set it with the `setUserId` function. If you're using\nthe [Meteor accounts system](#accounts_api) then this is handled for you.\n\n",["#",[[0,"with"],[0,"method_invocation_setUserId"]],[[">","api_box"]]],"\n\nCall this function to change the currently logged in user on the\nconnection that made this method call. This simply sets the value of\n`userId` for future method calls received on this connection. Pass\n`null` to log out the connection.\n\nIf you are using the [built-in Meteor accounts system](#accounts_api) then this\nshould correspond to the `_id` field of a document in the\n[`Meteor.users`](#meteor_users) collection.\n\n`setUserId` is not retroactive. It affects the current method call and\nany future method calls on the connection. Any previous method calls on\nthis connection will still see the value of `userId` that was in effect\nwhen they started.\n\n",["#",[[0,"with"],[0,"method_invocation_isSimulation"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"method_invocation_unblock"]],[[">","api_box"]]],"\n\nOn the server, methods from a given client run one at a time. The N+1th\ninvocation from a client won't start until the Nth invocation\nreturns. However, you can change this by calling `this.unblock`. This\nwill allow the N+1th invocation to start running in a new fiber.\n\n",["#",[[0,"with"],[0,"error"]],[[">","api_box"]]],"\n\nIf you want to return an error from a method, throw an exception.  Methods can\nthrow any kind of exception.  But `Meteor.Error` is the only kind of error that\na server will send to the client. If a method function throws a different\nexception, then it will be mapped to a sanitized version on the\nwire. Specifically, if the `sanitizedError` field on the thrown error is set to\na `Meteor.Error`, then that error will be sent to the client. Otherwise, if no\nsanitized version is available, the client gets\n`Meteor.Error(500, 'Internal server error')`.\n\n",["#",[[0,"with"],[0,"meteor_call"]],[[">","api_box"]]],"\n\nThis is how to invoke a method.  It will run the method on the server.  If a\nstub is available, it will also run the stub on the client.  (See also\n[`Meteor.apply`](#meteor_apply), which is identical to `Meteor.call` except that\nyou specify the parameters as an array instead of as separate arguments and you\ncan specify a few options controlling how the method is executed.)\n\nIf you include a callback function as the last argument (which can't be\nan argument to the method, since functions aren't serializable), the\nmethod will run asynchronously: it will return nothing in particular and\nwill not throw an exception.  When the method is complete (which may or\nmay not happen before `Meteor.call` returns), the callback will be\ncalled with two arguments: `error` and `result`. If an error was thrown,\nthen `error` will be the exception object.  Otherwise, `error` will be\nundefined and the return value (possibly undefined) will be in `result`.\n\n    // async call\n    Meteor.call('foo', 1, 2, function (error, result) { ... } );\n\nIf you do not pass a callback on the server, the method invocation will\nblock until the method is complete.  It will eventually return the\nreturn value of the method, or it will throw an exception if the method\nthrew an exception. (Possibly mapped to 500 Server Error if the\nexception happened remotely and it was not a `Meteor.Error` exception.)\n\n    // sync call\n    var result = Meteor.call('foo', 1, 2);\n\nOn the client, if you do not pass a callback and you are not inside a\nstub, `call` will return `undefined`, and you will have no way to get\nthe return value of the method. That is because the client doesn't have\nfibers, so there is not actually any way it can block on the remote\nexecution of a method.\n\nFinally, if you are inside a stub on the client and call another\nmethod, the other method is not executed (no RPC is generated, nothing\n\"real\" happens).  If that other method has a stub, that stub stands in\nfor the method and is executed. The method call's return value is the\nreturn value of the stub function.  The client has no problem executing\na stub synchronously, and that is why it's okay for the client to use\nthe synchronous `Meteor.call` form from inside a method body, as\ndescribed earlier.\n\nMeteor tracks the database writes performed by methods, both on the client and\nthe server, and does not invoke `asyncCallback` until all of the server's writes\nreplace the stub's writes in the local cache. In some cases, there can be a lag\nbetween the method's return value being available and the writes being visible:\nfor example, if another method still outstanding wrote to the same document, the\nlocal cache may not be up to date until the other method finishes as well. If\nyou want to process the method's result as soon as it arrives from the server,\neven if the method's writes are not available yet, you can specify an\n`onResultReceived` callback to [`Meteor.apply`](#meteor_apply).\n\n",["#",[[0,"with"],[0,"meteor_apply"]],[[">","api_box"]]],"\n\n`Meteor.apply` is just like `Meteor.call`, except that the method arguments are\npassed as an array rather than directly as arguments, and you can specify\noptions about how the client executes the method.\n\n<h2 id=\"connections\"><span>Server connections</span></h2>\n\nThese functions manage and inspect the network connection between the\nMeteor client and server.\n\n",["#",[[0,"with"],[0,"status"]],[[">","api_box"]]],"\n\nThis method returns the status of the connection between the client and\nthe server. The return value is an object with the following fields:\n\n<dl class=\"objdesc\">\n",["#",[[0,"dtdd"],{"name":"connected","type":"Boolean"}],["\n  True if currently connected to the server. If false, changes and\n  method invocations will be queued up until the connection is\n  reestablished.\n"]],"\n\n",["#",[[0,"dtdd"],{"name":"status","type":"String"}],["\n  Describes the current reconnection status. The possible\n  values are `connected` (the connection is up and\n  running), `connecting` (disconnected and trying to open a\n  new connection), `failed` (permanently failed to connect; e.g., the client\n  and server support different versions of DDP), `waiting` (failed\n  to connect and waiting to try to reconnect) and `offline` (user has disconnected the connection).\n"]],"\n\n",["#",[[0,"dtdd"],{"name":"retryCount","type":"Number"}],["\n  The number of times the client has tried to reconnect since the\n  connection was lost. 0 when connected.\n"]],"\n\n",["#",[[0,"dtdd"],{"name":"retryTime","type":"Number or undefined"}],["\n  The estimated time of the next reconnection attempt. To turn this\n  into an interval until the next reconnection, use\n  `retryTime - (new Date()).getTime()`. This key will\n  be set only when `status` is `waiting`.\n"]],"\n\n",["#",[[0,"dtdd"],{"name":"reason","type":"String or undefined"}],["\n  If `status` is `failed`, a description of why the connection failed.\n"]],"\n</dl>\n\nInstead of using callbacks to notify you on changes, this is\na [reactive](#reactivity) data source. You can use it in a\n[template](#templates) or [computation](#deps_autorun)\nto get realtime updates.\n\n",["#",[[0,"with"],[0,"reconnect"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"disconnect"]],[[">","api_box"]]],"\n\nCall this method to disconnect from the server and stop all\nlive data updates. While the client is disconnected it will not receive\nupdates to collections, method calls will be queued until the\nconnection is reestablished, and hot code push will be disabled.\n\nCall [Meteor.reconnect](#meteor_reconnect) to reestablish the connection\nand resume data transfer.\n\nThis can be used to save battery on mobile devices when real time\nupdates are not required.\n\n",["#",[[0,"with"],[0,"connect"]],[[">","api_box"]]],"\n\nTo call methods on another Meteor application or subscribe to its data\nsets, call `DDP.connect` with the URL of the application.\n`DDP.connect` returns an object which provides:\n\n* `subscribe` -\n  Subscribe to a record set. See\n  [Meteor.subscribe](#meteor_subscribe).\n* `call` -\n  Invoke a method. See [Meteor.call](#meteor_call).\n* `apply` -\n  Invoke a method with an argument array. See\n  [Meteor.apply](#meteor_apply).\n* `methods` -\n  Define client-only stubs for methods defined on the remote server. See\n  [Meteor.methods](#meteor_methods).\n* `status` -\n  Get the current connection status. See\n  [Meteor.status](#meteor_status).\n* `reconnect` -\n  See [Meteor.reconnect](#meteor_reconnect).\n* `disconnect` -\n  See [Meteor.disconnect](#meteor_disconnect).\n* `onReconnect` - Set this to a function to be called as the first step of\n  reconnecting. This function can call methods which will be executed before\n  any other outstanding methods. For example, this can be used to re-establish\n  the appropriate authentication context on the new connection.\n\nBy default, clients open a connection to the server from which they're loaded.\nWhen you call `Meteor.subscribe`, `Meteor.status`, `Meteor.call`, and\n`Meteor.apply`, you are using a connection back to that default\nserver.\n\n<h2 id=\"collections\"><span>Collections</span></h2>\n\nMeteor stores data in *collections*.  To get started, declare a\ncollection with `new Meteor.Collection`.\n\n",["#",[[0,"with"],[0,"meteor_collection"]],[[">","api_box"]]],"\n\nCalling this function is analogous to declaring a model in a traditional ORM\n(Object-Relation Mapper)-centric framework. It sets up a *collection* (a storage\nspace for records, or \"documents\") that can be used to store a particular type\nof information, like users, posts, scores, todo items, or whatever matters to\nyour application.  Each document is a EJSON object.  It includes an `_id`\nproperty whose value is unique in the collection, which Meteor will set when you\nfirst create the document.\n\n    // common code on client and server declares livedata-managed mongo\n    // collection.\n    Chatrooms = new Meteor.Collection(\"chatrooms\");\n    Messages = new Meteor.Collection(\"messages\");\n\nThe function returns an object with methods to [`insert`](#insert)\ndocuments in the collection, [`update`](#update) their properties, and\n[`remove`](#remove) them, and to [`find`](#find) the documents in the\ncollection that match arbitrary criteria. The way these methods work is\ncompatible with the popular Mongo database API.  The same database API\nworks on both the client and the server (see below).\n\n    // return array of my messages\n    var myMessages = Messages.find({userId: Session.get('myUserId')}).fetch();\n\n    // create a new message\n    Messages.insert({text: \"Hello, world!\"});\n\n    // mark my first message as \"important\"\n    Messages.update(myMessages[0]._id, {$set: {important: true}});\n\nIf you pass a `name` when you create the collection, then you are\ndeclaring a persistent collection &mdash; one that is stored on the\nserver and seen by all users. Client code and server code can both\naccess the same collection using the same API.\n\nSpecifically, when you pass a `name`, here's what happens:\n\n* On the server, a collection with that name is created on a backend\nMongo server. When you call methods on that collection on the server,\nthey translate directly into normal Mongo operations (after checking that\nthey match your [access control rules](#allow)).\n\n* On the client, a Minimongo instance is\ncreated. Minimongo is essentially an in-memory, non-persistent\nimplementation of Mongo in pure JavaScript. It serves as a local cache\nthat stores just the subset of the database that this client is working\nwith. Queries on the client ([`find`](#find)) are served directly out of\nthis cache, without talking to the server.\n\n* When you write to the database on the client ([`insert`](#insert),\n[`update`](#update), [`remove`](#remove)), the command is executed\nimmediately on the client, and, simultaneously, it's shipped up to the\nserver and executed there too.  The `livedata` package is\nresponsible for this.\n\nIf you pass `null` as the `name`, then you're creating a local\ncollection. It's not synchronized anywhere; it's just a local scratchpad\nthat supports Mongo-style [`find`](#find), [`insert`](#insert),\n[`update`](#update), and [`remove`](#remove) operations.  (On both the\nclient and the server, this scratchpad is implemented using Minimongo.)\n\nBy default, Meteor automatically publishes every document in your\ncollection to each connected client.  To turn this behavior off, remove\nthe `autopublish` package:\n\n    $ meteor remove autopublish\n\nand instead call [`Meteor.publish`](#meteor_publish) to specify which parts of\nyour collection should be published to which users.\n\n    // Create a collection called Posts and put a document in it. The\n    // document will be immediately visible in the local copy of the\n    // collection. It will be written to the server-side database\n    // a fraction of a second later, and a fraction of a second\n    // after that, it will be synchronized down to any other clients\n    // that are subscribed to a query that includes it (see\n    // Meteor.subscribe and autopublish)\n    Posts = new Meteor.Collection(\"posts\");\n    Posts.insert({title: \"Hello world\", body: \"First post\"});\n\n    // Changes are visible immediately -- no waiting for a round trip to\n    // the server.\n    assert(Posts.find().count() === 1);\n\n    // Create a temporary, local collection. It works just like any other\n    // collection, but it doesn't send changes to the server, and it\n    // can't receive any data from subscriptions.\n    Scratchpad = new Meteor.Collection;\n    for (var i = 0; i < 10; i++)\n      Scratchpad.insert({number: i * 2});\n    assert(Scratchpad.find({number: {$lt: 9}}).count() === 5);\n\n\nIf you specify a `transform` option to the `Collection` or any of its retrieval\nmethods, documents are passed through the `transform` function before being\nreturned or passed to callbacks.  This allows you to add methods or otherwise\nmodify the contents of your collection from their database representation.  You\ncan also specify `transform` on a particular `find`, `findOne`, `allow`, or\n`deny` call.\n\n    // An Animal class that takes a document in its constructor\n    Animal = function (doc) {\n      _.extend(this, doc);\n    };\n    _.extend(Animal.prototype, {\n      makeNoise: function () {\n        console.log(this.sound);\n      }\n    });\n\n    // Define a Collection that uses Animal as its document\n    Animals = new Meteor.Collection(\"Animals\", {\n      transform: function (doc) { return new Animal(doc); }\n    });\n\n    // Create an Animal and call its makeNoise method\n    Animals.insert({name: \"raptor\", sound: \"roar\"});\n    Animals.findOne({name: \"raptor\"}).makeNoise(); // prints \"roar\"\n\n`transform` functions are not called reactively.  If you want to add a\ndynamically changing attribute to an object, do it with a function that computes\nthe value at the time it's called, not by computing the attribute at `transform`\ntime.\n\n",["#",[[0,"warning"]],["\nIn this release, Minimongo has some limitations:\n\n* `$pull` in modifiers can only accept certain kinds\nof selectors.\n* `$` to denote the matched array position is not\nsupported in modifier.\n* `findAndModify`, upsert, aggregate functions, and\nmap/reduce aren't supported.\n\nAll of these will be addressed in a future release. For full\nMinimongo release notes, see packages/minimongo/NOTES\nin the repository.\n"]],"\n\n",["#",[[0,"warning"]],["\nMinimongo doesn't currently have indexes. It's rare for this to be an\nissue, since it's unusual for a client to have enough data that an\nindex is worthwhile.\n"]],"\n\n",["#",[[0,"with"],[0,"find"]],[[">","api_box"]]],"\n\n`find` returns a cursor.  It does not immediately access the database or return\ndocuments.  Cursors provide `fetch` to return all matching documents, `map` and\n`forEach` to iterate over all matching documents, and `observe` and\n`observeChanges` to register callbacks when the set of matching documents\nchanges.\n\n",["#",[[0,"warning"]],["\nCollection cursors are not query snapshots.  If the database changes\nbetween calling `Collection.find` and fetching the\nresults of the cursor, or while fetching results from the cursor,\nthose changes may or may not appear in the result set.\n"]],"\n\nCursors are a reactive data source.  The first time you retrieve a\ncursor's documents with `fetch`, `map`, or `forEach` inside a\nreactive computation (eg, a template or\n[`autorun`](#deps_autorun)), Meteor will register a\ndependency on the underlying data.  Any change to the collection that\nchanges the documents in a cursor will trigger a recomputation.  To\ndisable this behavior, pass `{reactive: false}` as an option to\n`find`.\n\n",["#",[[0,"with"],[0,"findone"]],[[">","api_box"]]],"\n\nEquivalent to `find(selector, options).fetch()[0]` with\n`options.limit = 1`.\n\n",["#",[[0,"with"],[0,"insert"]],[[">","api_box"]]],"\n\nAdd a document to the collection. A document is just an object, and\nits fields can contain any combination of EJSON-compatible datatypes\n(arrays, objects, numbers, strings, `null`, true, and false).\n\n`insert` will generate a unique ID for the object you pass, insert it\nin the database, and return the ID. When `insert` is called from\nuntrusted client code, it will be allowed only if passes any\napplicable [`allow`](#allow) and [`deny`](#deny) rules.\n\nOn the server, if you don't provide a callback, then `insert` blocks\nuntil the database acknowledges the write, or throws an exception if\nsomething went wrong.  If you do provide a callback, `insert` still\nreturns the ID immediately.  Once the insert completes (or fails), the\ncallback is called with error and result arguments.  In an error case,\n`result` is undefined.  If the insert is successful, `error` is\nundefined and `result` is the new document ID.\n\nOn the client, `insert` never blocks.  If you do not provide a callback\nand the insert fails on the server, then Meteor will log a warning to\nthe console.  If you provide a callback, Meteor will call that function\nwith `error` and `result` arguments.  In an error case, `result` is\nundefined.  If the insert is successful, `error` is undefined and\n`result` is the new document ID.\n\nExample:\n\n    var groceriesId = Lists.insert({name: \"Groceries\"});\n    Items.insert({list: groceriesId, name: \"Watercress\"});\n    Items.insert({list: groceriesId, name: \"Persimmons\"});\n\n",["#",[[0,"with"],[0,"update"]],[[">","api_box"]]],"\n\nModify documents that match `selector` according to `modifier` (see\n[modifier documentation](#modifiers)).\n\nThe behavior of `update` differs depending on whether it is called by\ntrusted or untrusted code. Trusted code includes server code and\nmethod code. Untrusted code includes client-side code such as event\nhandlers and a browser's JavaScript console.\n\n- Trusted code can modify multiple documents at once by setting\n  `multi` to true, and can use an arbitrary [Mongo\n  selector](#selectors) to find the documents to modify. It bypasses\n  any access control rules set up by [`allow`](#allow) and\n  [`deny`](#deny).\n\n- Untrusted code can only modify a single document at once, specified\n  by its `_id`. The modification is allowed only after checking any\n  applicable [`allow`](#allow) and [`deny`](#deny) rules.\n\nOn the server, if you don't provide a callback, then `update` blocks\nuntil the database acknowledges the write, or throws an exception if\nsomething went wrong.  If you do provide a callback, `update` returns\nimmediately.  Once the update completes, the callback is called with a\nsingle error argument in the case of failure, or no arguments if the\nupdate was successful.\n\nOn the client, `update` never blocks.  If you do not provide a callback\nand the update fails on the server, then Meteor will log a warning to\nthe console.  If you provide a callback, Meteor will call that function\nwith an error argument if there was an error, or no arguments if the\nupdate was successful.\n\nClient example:\n\n    // When the givePoints button in the admin dashboard is pressed,\n    // give 5 points to the current player. The new score will be\n    // immediately visible on everyone's screens.\n    Template.adminDashboard.events({\n      'click .givePoints': function () {\n        Players.update(Session.get(\"currentPlayer\"), {$inc: {score: 5}});\n      }\n    });\n\nServer example:\n\n    // Give the \"Winner\" badge to each user with a score greater than\n    // 10. If they are logged in and their badge list is visible on the\n    // screen, it will update automatically as they watch.\n    Meteor.methods({\n      declareWinners: function () {\n        Players.update({score: {$gt: 10}},\n                       {$addToSet: {badges: \"Winner\"}},\n                       {multi: true});\n      }\n    });\n\n",["#",[[0,"warning"]],["\nThe Mongo `upsert` feature is not implemented.\n"]],"\n\n",["#",[[0,"with"],[0,"remove"]],[[">","api_box"]]],"\n\nFind all of the documents that match `selector` and delete them from\nthe collection.\n\nThe behavior of `remove` differs depending on whether it is called by\ntrusted or untrusted code. Trusted code includes server code and\nmethod code. Untrusted code includes client-side code such as event\nhandlers and a browser's JavaScript console.\n\n- Trusted code can use an arbitrary [Mongo selector](#selectors) to\n  find the documents to remove, and can remove more than one document\n  at once by passing a selector that matches multiple documents. It\n  bypasses any access control rules set up by [`allow`](#allow) and\n  [`deny`](#deny).\n\n  As a safety measure, if `selector` is omitted (or is `undefined`),\n  no documents will be removed. Set `selector` to `{}` if you really\n  want to remove all documents from your collection.\n\n- Untrusted code can only remove a single document at a time,\n  specified by its `_id`. The document is removed only after checking\n  any applicable [`allow`](#allow) and [`deny`](#deny) rules.\n\nOn the server, if you don't provide a callback, then `remove` blocks\nuntil the database acknowledges the write, or throws an exception if\nsomething went wrong.  If you do provide a callback, `remove` returns\nimmediately.  Once the remove completes, the callback is called with a\nsingle error argument in the case of failure, or no arguments if the\nremove was successful.\n\nOn the client, `remove` never blocks.  If you do not provide a callback\nand the remove fails on the server, then Meteor will log a warning to\nthe console.  If you provide a callback, Meteor will call that function\nwith an error argument if there was an error, or no arguments if the\nremove was successful.\n\nClient example:\n\n    // When the remove button is clicked on a chat message, delete\n    // that message.\n    Template.chat.events({\n      'click .remove': function () {\n        Messages.remove(this._id);\n      }\n    });\n\nServer example:\n\n    // When the server starts, clear the log, and delete all players\n    // with a karma of less than -2.\n    Meteor.startup(function () {\n      if (Meteor.isServer) {\n        Logs.remove({});\n        Players.remove({karma: {$lt: -2}});\n      }\n    });\n\n",["#",[[0,"with"],[0,"allow"]],[[">","api_box"]]],"\n\nWhen a client calls `insert`, `update`, or `remove` on a collection, the\ncollection's `allow` and [`deny`](#deny) callbacks are called\non the server to determine if the write should be allowed. If at least\none `allow` callback allows the write, and no `deny` callbacks deny the\nwrite, then the write is allowed to proceed.\n\nThese checks are run only when a client tries to write to the database\ndirectly, for example by calling `update` from inside an event\nhandler. Server code is trusted and isn't subject to `allow` and `deny`\nrestrictions. That includes methods that are called with `Meteor.call`\n&mdash; they are expected to do their own access checking rather than\nrelying on `allow` and `deny`.\n\nYou can call `allow` as many times as you like, and each call can\ninclude any combination of `insert`, `update`, and `remove`\nfunctions. The functions should return `true` if they think the\noperation should be allowed. Otherwise they should return `false`, or\nnothing at all (`undefined`). In that case Meteor will continue\nsearching through any other `allow` rules on the collection.\n\nThe available callbacks are:\n\n<dl class=\"callbacks\">\n",["#",[[0,"dtdd"],"insert(userId, doc)"],["\nThe user `userId` wants to insert the document `doc` into the\ncollection. Return `true` if this should be allowed.\n"]],"\n\n",["#",[[0,"dtdd"],"update(userId, doc, fieldNames, modifier)"],["\n\nThe user `userId` wants to update a document `doc`. (`doc` is the\ncurrent version of the document from the database, without the\nproposed update.) Return `true` to permit the change.\n\n`fieldNames` is an array of the (top-level) fields in `doc` that the\nclient wants to modify, for example\n`['name',`&nbsp;`'score']`. `modifier` is the raw Mongo modifier that\nthe client wants to execute, for example `{$set: {'name.first':\n\"Alice\"}, $inc: {score: 1}}`.\n\nOnly Mongo modifiers are supported (operations like `$set` and `$push`).\nIf the user tries to replace the entire document rather than use\n$-modifiers, the request will be denied without checking the `allow`\nfunctions.\n\n"]],"\n\n",["#",[[0,"dtdd"],"remove(userId, doc)"],["\n\nThe user `userId` wants to remove `doc` from the database. Return\n`true` to permit this.\n\n"]],"\n\n</dl>\n\nWhen calling `update` or `remove` Meteor will by default fetch the\nentire document `doc` from the database. If you have large documents\nyou may wish to fetch only the fields that are actually used by your\nfunctions. Accomplish this by setting `fetch` to an array of field\nnames to retrieve.\n\nExample:\n\n    // Create a collection where users can only modify documents that\n    // they own. Ownership is tracked by an 'owner' field on each\n    // document. All documents must be owned by the user that created\n    // them and ownership can't be changed. Only a document's owner\n    // is allowed to delete it, and the 'locked' attribute can be\n    // set on a document to prevent its accidental deletion.\n\n    Posts = new Meteor.Collection(\"posts\");\n\n    Posts.allow({\n      insert: function (userId, doc) {\n        // the user must be logged in, and the document must be owned by the user\n        return (userId && doc.owner === userId);\n      },\n      update: function (userId, doc, fields, modifier) {\n        // can only change your own documents\n        return doc.owner === userId;\n      },\n      remove: function (userId, doc) {\n        // can only remove your own documents\n        return doc.owner === userId;\n      },\n      fetch: ['owner']\n    });\n\n    Posts.deny({\n      update: function (userId, docs, fields, modifier) {\n        // can't change owners\n        return _.contains(fields, 'owner');\n      },\n      remove: function (userId, doc) {\n        // can't remove locked documents\n        return doc.locked;\n      },\n      fetch: ['locked'] // no need to fetch 'owner'\n    });\n\nIf you never set up any `allow` rules on a collection then all client\nwrites to the collection will be denied, and it will only be possible to\nwrite to the collection from server-side code. In this case you will\nhave to create a method for each possible write that clients are allowed\nto do. You'll then call these methods with `Meteor.call` rather than\nhaving the clients call `insert`, `update`, and `remove` directly on the\ncollection.\n\nMeteor also has a special \"insecure mode\" for quickly prototyping new\napplications. In insecure mode, if you haven't set up any `allow` or `deny`\nrules on a collection, then all users have full write access to the\ncollection. This is the only effect of insecure mode. If you call `allow` or\n`deny` at all on a collection, even `Posts.allow({})`, then access is checked\njust like normal on that collection. __New Meteor projects start in insecure\nmode by default.__ To turn it off just run `$ meteor remove insecure`.\n\n",["#",[[0,"with"],[0,"deny"]],[[">","api_box"]]],"\n\nThis works just like [`allow`](#allow), except it lets you\nmake sure that certain writes are definitely denied, even if there is an\n`allow` rule that says that they should be permitted.\n\nWhen a client tries to write to a collection, the Meteor server first\nchecks the collection's `deny` rules. If none of them return true then\nit checks the collection's `allow` rules. Meteor allows the write only\nif no `deny` rules return `true` and at least one `allow` rule returns\n`true`.\n\n<h2 id=\"meteor_collection_cursor\"><span>Cursors</span></h2>\n\nTo create a cursor, use [`find`](#find).  To access the documents in a\ncursor, use [`forEach`](#foreach), [`map`](#map), or [`fetch`](#fetch).\n\n",["#",[[0,"with"],[0,"cursor_foreach"]],[[">","api_box"]]],"\n\nWhen called from a reactive computation, `forEach` registers dependencies on\nthe matching documents.\n\nExamples:\n\n    // Print the titles of the five top-scoring posts\n    var topPosts = Posts.find({}, {sort: {score: -1}, limit: 5});\n    var count = 0;\n    topPosts.forEach(function (post) {\n      console.log(\"Title of post \" + count + \": \" + post.title);\n      count += 1;\n    });\n\n",["#",[[0,"with"],[0,"cursor_map"]],[[">","api_box"]]],"\n\nWhen called from a reactive computation, `map` registers dependencies on\nthe matching documents.\n\n<!-- The following is not yet implemented, but users shouldn't assume\n     sequential execution anyway because that will break. -->\nOn the server, if `callback` yields, other calls to `callback` may occur while\nthe first call is waiting. If strict sequential execution is necessary, use\n`forEach` instead.\n\n",["#",[[0,"with"],[0,"cursor_fetch"]],[[">","api_box"]]],"\n\nWhen called from a reactive computation, `fetch` registers dependencies on\nthe matching documents.\n\n",["#",[[0,"with"],[0,"cursor_count"]],[[">","api_box"]]],"\n\n    // Display a count of posts matching certain criteria. Automatically\n    // keep it updated as the database changes.\n    var frag = Meteor.render(function () {\n      var highScoring = Posts.find({score: {$gt: 10}});\n      return \"<p>There are \" + highScoring.count() + \" posts with \" +\n        \"scores greater than 10</p>\";\n    });\n    document.body.appendChild(frag);\n\nUnlike the other functions, `count` registers a dependency only on the\nnumber of matching documents.  (Updates that just change or reorder the\ndocuments in the result set will not trigger a recomputation.)\n\n",["#",[[0,"with"],[0,"cursor_rewind"]],[[">","api_box"]]],"\n\nThe `forEach`, `map`, or `fetch` methods can only be called once on a\ncursor.  To access the data in a cursor more than once, use `rewind` to\nreset the cursor.\n\n",["#",[[0,"with"],[0,"cursor_observe"]],[[">","api_box"]]],"\n\nEstablishes a *live query* that invokes callbacks when the result of\nthe query changes. The callbacks receive the entire contents of the\ndocument that was affected, as well as its old contents, if\napplicable. If you only need to receive the fields that changed, see\n[`observeChanges`](#observe_changes).\n\n`callbacks` may have the following functions as properties:\n\n<dl class=\"callbacks\">\n<dt><span class=\"name\">added(document)</span> <span class=\"or\">or</span></dt>\n<dt><span class=\"name\">addedAt(document, atIndex, before)</span></dt>\n<dd>\n",["#",[[0,"better_markdown"]],["\nA new document `document` entered the result set. The new document\nappears at position `atIndex`. It is immediately before the document\nwhose `_id` is `before`. `before` will be `null` if the new document\nis at the end of the results.\n"]],"\n</dd>\n\n<dt><span class=\"name\">changed(newDocument, oldDocument)\n    <span class=\"or\">or</span></span></dt>\n<dt><span class=\"name\">changedAt(newDocument, oldDocument, atIndex)</span></dt>\n<dd>\n",["#",[[0,"better_markdown"]],["\nThe contents of a document were previously `oldDocument` and are now\n`newDocument`. The position of the changed document is `atIndex`.\n"]],"\n</dd>\n\n<dt><span class=\"name\">removed(oldDocument)</span>\n  <span class=\"or\">or</span></dt>\n<dt><span class=\"name\">removedAt(oldDocument, atIndex)</span></dt>\n<dd>\n",["#",[[0,"better_markdown"]],["\nThe document `oldDocument` is no longer in the result set. It used to be at position `atIndex`.\n"]],"\n</dd>\n\n",["#",[[0,"dtdd"],"movedTo(document, fromIndex, toIndex, before)"],["\nA document changed its position in the result set, from `fromIndex` to `toIndex`\n(which is before the document with id `before`). Its current contents is\n`document`.\n"]],"\n</dl>\n\nUse `added`, `changed`, and `removed` when you don't care about the\norder of the documents in the result set. They are more efficient than\n`addedAt`, `changedAt`, and `removedAt`.\n\nBefore `observe` returns, `added` (or `addedAt`) will be called zero\nor more times to deliver the initial results of the query.\n\n`observe` returns a live query handle, which is an object with a `stop` method.\nCall `stop` with no arguments to stop calling the callback functions and tear\ndown the query. **The query will run forever until you call this.**  If\n`observe` is called from a `Deps.autorun` computation, it is automatically\nstopped when the computation is rerun or stopped.\n(If the cursor was created with the option `reactive` set to false, it will\nonly deliver the initial results and will not call any further callbacks;\nit is not necessary to call `stop` on the handle.)\n\n\n",["#",[[0,"with"],[0,"cursor_observe_changes"]],[[">","api_box"]]],"\n\nEstablishes a *live query* that invokes callbacks when the result of\nthe query changes. In contrast to [`observe`](#observe),\n`observeChanges` provides only the difference between the old and new\nresult set, not the entire contents of the document that changed.\n\n`callbacks` may have the following functions as properties:\n\n<dl class=\"callbacks\">\n<dt><span class=\"name\">added(id, fields)</span>\n  <span class=\"or\">or</span></dt>\n<dt><span class=\"name\">addedBefore(id, fields, before)</span></dt>\n<dd>\n",["#",[[0,"better_markdown"]],["\nA new document entered the result set. It has the `id` and `fields`\nspecified. `fields` contains all fields of the document excluding the\n`_id` field. The new document is before the document identified by\n`before`, or at the end if `before` is `null`.\n"]],"\n</dd>\n\n",["#",[[0,"dtdd"],"changed(id, fields)"],["\nThe document identified by `id` has changed. `fields` contains the\nchanged fields with their new values. If a field was removed from the\ndocument then it will be present in `fields` with a value of\n`undefined`.\n"]],"\n\n",["#",[[0,"dtdd"],"movedBefore(id, before)"],["\nThe document identified by `id` changed its position in the ordered result set,\nand now appears before the document identified by `before`.\n"]],"\n\n",["#",[[0,"dtdd"],"removed(id)"],["\nThe document identified by `id` was removed from the result set.\n"]],"\n</dl>\n\n`observeChanges` is significantly more efficient if you do not use\n`addedBefore` or `movedBefore`.\n\nBefore `observeChanges` returns, `added` (or `addedBefore`) will be called\nzero or more times to deliver the initial results of the query.\n\n`observeChanges` returns a live query handle, which is an object with a `stop`\nmethod.  Call `stop` with no arguments to stop calling the callback functions\nand tear down the query. **The query will run forever until you call this.**\nIf\n`observeChanges` is called from a `Deps.autorun` computation, it is automatically\nstopped when the computation is rerun or stopped.\n(If the cursor was created with the option `reactive` set to false, it will\nonly deliver the initial results and will not call any further callbacks;\nit is not necessary to call `stop` on the handle.)\n\n",["#",[[0,"note"]],["\nUnlike `observe`, `observeChanges` does not provide absolute position\ninformation (that is, `atIndex` positions rather than `before`\npositions.) This is for efficiency.\n"]],"\n\nExample:\n\n    // Keep track of how many administrators are online.\n    var count = 0;\n    var query = Users.find({admin: true, onlineNow: true});\n    var handle = query.observeChanges({\n      added: function (id, user) {\n        count++;\n        console.log(user.name + \" brings the total to \" + count + \" admins.\");\n      },\n      removed: function () {\n        count--;\n        console.log(\"Lost one. We're now down to \" + count + \" admins.\");\n      }\n    });\n\n    // After five seconds, stop keeping the count.\n    setTimeout(function () {handle.stop();}, 5000);\n\n",["#",[[0,"with"],[0,"collection_object_id"]],[[">","api_box"]]],"\n\n`Meteor.Collection.ObjectID` follows the same API as the [Node MongoDB driver\n`ObjectID`](http://mongodb.github.com/node-mongodb-native/api-bson-generated/objectid.html)\nclass. Note that you must use the `equals` method (or [`EJSON.equals`](#ejson_equals)) to\ncompare them; the `===` operator will not work. If you are writing generic code\nthat needs to deal with `_id` fields that may be either strings or `ObjectID`s, use\n[`EJSON.equals`](#ejson_equals) instead of `===` to compare them.\n\n",["#",[[0,"note"]],["\n  `ObjectID` values created by Meteor will not have meaningful answers to their `getTimestamp`\n  method, since Meteor currently constructs them fully randomly.\n"]],"\n\n",["#",[[0,"api_box_inline"],[0,"selectors"]],["\n\nIn its simplest form, a selector is just a set of keys that must\nmatch in a document:\n\n    // Matches all documents where deleted is false\n    {deleted: false}\n\n    // Matches all documents where the name and cognomen are as given\n    {name: \"Rhialto\", cognomen: \"the Marvelous\"}\n\n    // Matches every document\n    {}\n\nBut they can also contain more complicated tests:\n\n    // Matches documents where age is greater than 18\n    {age: {$gt: 18}}\n\n    // Also matches documents where tags is an array containing \"popular\"\n    {tags: \"popular\"}\n\n    // Matches documents where fruit is one of three possibilities\n    {fruit: {$in: [\"peach\", \"plum\", \"pear\"]}}\n\nSee the [complete\ndocumentation](http://www.mongodb.org/display/DOCS/Advanced+Queries).\n\n"]],"\n\n",["#",[[0,"api_box_inline"],[0,"modifiers"]],["\n\nA modifier is an object that describes how to update a document in\nplace by changing some of its fields. Some examples:\n\n    // Set the 'admin' property on the document to true\n    {$set: {admin: true}}\n\n    // Add 2 to the 'votes' property, and add \"Traz\"\n    // to the end of the 'supporters' array\n    {$inc: {votes: 2}, $push: {supporters: \"Traz\"}}\n\nBut if a modifier doesn't contain any $-operators, then it is instead\ninterpreted as a literal document, and completely replaces whatever was\npreviously in the database. (Literal document modifiers are not currently\nsupported by [validated updates](#allow).)\n\n    // Find the document with id \"123\", and completely replace it.\n    Users.update({_id: \"123\"}, {name: \"Alice\", friends: [\"Bob\"]});\n\nSee the [full list of\nmodifiers](http://www.mongodb.org/display/DOCS/Updating#Updating-ModifierOperations).\n\n"]],"\n\n",["#",[[0,"api_box_inline"],[0,"sortspecifiers"]],["\n\nSorts may be specified using your choice of several syntaxes:\n\n    // All of these do the same thing (sort in ascending order by\n    // key \"a\", breaking ties in descending order of key \"b\")\n\n    [[\"a\", \"asc\"], [\"b\", \"desc\"]]\n    [\"a\", [\"b\", \"desc\"]]\n    {a: 1, b: -1}\n\nThe last form will only work if your JavaScript implementation\npreserves the order of keys in objects. Most do, most of the time, but\nit's up to you to be sure.\n\n"]],"\n\n",["#",[[0,"api_box_inline"],[0,"fieldspecifiers"]],["\n\nOn the server, queries can specify a particular set of fields to include\nor exclude from the result object.  (The field specifier is currently\nignored on the client.)\n\nTo exclude certain fields from the result objects, the field specifier\nis a dictionary whose keys are field names and whose values are `0`.\n\n    // Users.find({}, {fields: {password: 0, hash: 0}})\n\nTo return an object that only includes the specified field, use `1` as\nthe value.  The `_id` field is still included in the result.\n\n    // Users.find({}, {fields: {firstname: 1, lastname: 1}})\n\nIt is not possible to mix inclusion and exclusion styles.\n\n"]],"\n\n<h2 id=\"session\"><span>Session</span></h2>\n\n`Session` provides a global object on the client that you can use to\nstore an arbitrary set of key-value pairs. Use it to store things like\nthe currently selected item in a list.\n\nWhat's special about `Session` is that it's reactive. If\nyou call [`Session.get`](#session_get)`(\"currentList\")`\nfrom inside a template, the template will automatically be rerendered\nwhenever [`Session.set`](#session_set)`(\"currentList\", x)` is called.\n\n",["#",[[0,"with"],[0,"set"]],[[">","api_box"]]],"\n\nExample:\n\n    Deps.autorun(function () {\n      Meteor.subscribe(\"chat-history\", {room: Session.get(\"currentRoomId\")});\n    });\n\n    // Causes the function passed to Deps.autorun to be re-run, so\n    // that the chat-history subscription is moved to the room \"home\".\n    Session.set(\"currentRoomId\", \"home\");\n\n",["#",[[0,"with"],[0,"setDefault"]],[[">","api_box"]]],"\n\nThis is useful in initialization code, to avoid re-initializing a session\nvariable every time a new version of your app is loaded.\n\n",["#",[[0,"with"],[0,"get"]],[[">","api_box"]]],"\n\nExample:\n\n    Session.set(\"enemy\", \"Eastasia\");\n    var frag = Meteor.render(function () {\n      return \"<p>We've always been at war with \" +\n        Session.get(\"enemy\") + \"</p>\";\n    });\n\n    // Page will say \"We've always been at war with Eastasia\"\n    document.body.append(frag);\n\n    // Page will change to say \"We've always been at war with Eurasia\"\n    Session.set(\"enemy\", \"Eurasia\");\n\n",["#",[[0,"with"],[0,"equals"]],[[">","api_box"]]],"\n\nIf value is a scalar, then these two expressions do the same thing:\n\n    (1) Session.get(\"key\") === value\n    (2) Session.equals(\"key\", value)\n\n... but the second one is always better. It triggers fewer invalidations\n(template redraws), making your program more efficient.\n\nExample:\n\n    <template name=\"postsView\">\n    ",["{",[[0,"dstache"]]],"! Show a dynamically updating list of items. Let the user click on an\n        item to select it. The selected item is given a CSS class so it\n        can be rendered differently. }}\n\n    ",["{",[[0,"dstache"]]],"#each posts}}\n      ",["{",[[0,"dstache"]]],"> postItem }}\n    ",["{",[[0,"dstache"]]],"/each}}\n    </","template>\n\n    <template name=\"postItem\">\n      <div class=\"",["{",[[0,"dstache"]]],"postClass}}\">",["{",[[0,"dstache"]]],"title}}</div>\n    </","template>\n\n    ///// in JS file\n    Template.postsView.posts = function() {\n      return Posts.find();\n    };\n\n    Template.postItem.postClass = function() {\n      return Session.equals(\"selectedPost\", this._id) ?\n        \"selected\" : \"\";\n    };\n\n    Template.postItem.events({\n      'click': function() {\n        Session.set(\"selectedPost\", this._id);\n      }\n    });\n\n    // Using Session.equals here means that when the user clicks\n    // on an item and changes the selection, only the newly selected\n    // and the newly unselected items are re-rendered.\n    //\n    // If Session.get had been used instead of Session.equals, then\n    // when the selection changed, all the items would be re-rendered.\n\nFor object and array session values, you cannot use `Session.equals`; instead,\nyou need to use the `underscore` package and write\n`_.isEqual(Session.get(key), value)`.\n\n\n\n<h2 id=\"accounts_api\"><span>Accounts</span></h2>\n\nThe Meteor Accounts system builds on top of the `userId` support in\n[`publish`](#publish_userId) and [`methods`](#method_userId). The core\npackages add the concept of user documents stored in the database, and\nadditional packages add [secure password\nauthentication](#accounts_passwords), [integration with third party\nlogin services](#meteor_loginwithexternalservice), and a [pre-built user\ninterface](#accountsui).\n\nThe basic Accounts system is in the `accounts-base` package, but\napplications typically include this automatically by adding one of the\nlogin provider packages: `accounts-password`, `accounts-facebook`,\n`accounts-github`, `accounts-google`, `accounts-meetup`,\n`accounts-twitter`, or `accounts-weibo`.\n\n\n",["#",[[0,"with"],[0,"user"]],[[">","api_box"]]],"\n\nRetrieves the user record for the current user from\nthe [`Meteor.users`](#meteor_users) collection.\n\nOn the client, this will be the subset of the fields in the document that\nare published from the server (other fields won't be available on the\nclient). By default the server publishes `username`, `emails`, and\n`profile`. See [`Meteor.users`](#meteor_users) for more on\nthe fields used in user documents.\n\n",["#",[[0,"with"],[0,"userId"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"users"]],[[">","api_box"]]],"\n\nThis collection contains one document per registered user. Here's an example\nuser document:\n\n    {\n      _id: \"bbca5d6a-2156-41c4-89da-0329e8c99a4f\",  // Meteor.userId()\n      username: \"cool_kid_13\", // unique name\n      emails: [\n        // each email address can only belong to one user.\n        { address: \"cool@example.com\", verified: true },\n        { address: \"another@different.com\", verified: false }\n      ],\n      createdAt: 1349761684042,\n      profile: {\n        // The profile is writable by the user by default.\n        name: \"Joe Schmoe\"\n      },\n      services: {\n        facebook: {\n          id: \"709050\", // facebook id\n          accessToken: \"AAACCgdX7G2...AbV9AZDZD\"\n        },\n        resume: {\n          loginTokens: [\n            { token: \"97e8c205-c7e4-47c9-9bea-8e2ccc0694cd\",\n              when: 1349761684048 }\n          ]\n        }\n      }\n    }\n\nA user document can contain any data you want to store about a user. Meteor\ntreats the following fields specially:\n\n- `username`: a unique String identifying the user.\n- `emails`: an Array of Objects with keys `address` and `verified`;\n  an email address may belong to at most one user. `verified` is\n  a Boolean which is true if the user has [verified the\n  address](#accounts_verifyemail) with a token sent over email.\n- `createdAt`: a numeric timestamp (milliseconds since January 1 1970)\n   of the time the user document was created.\n- `profile`: an Object which (by default) the user can create\n  and update with any data.\n- `services`: an Object containing data used by particular\n  login services. For example, its `reset` field contains\n  tokens used by [forgot password](#accounts_forgotpassword) links,\n  and its `resume` field contains tokens used to keep you\n  logged in between sessions.\n\nLike all [Meteor.Collection](#collections)s, you can access all\ndocuments on the server, but only those specifically published by the server are\navailable on the client.\n\nBy default, the current user's `username`, `emails` and `profile` are\npublished to the client. You can publish additional fields for the\ncurrent user with:\n\n    Meteor.publish(\"userData\", function () {\n      return Meteor.users.find({_id: this.userId},\n                               {fields: {'other': 1, 'things': 1}});\n    });\n\nIf the autopublish package is installed, information about all users\non the system is published to all clients. This includes `username`,\n`profile`, and any fields in `services` that are meant to be public\n(eg `services.facebook.id`,\n`services.twitter.screenName`). Additionally, when using autopublish\nmore information is published for the currently logged in user,\nincluding access tokens. This allows making API calls directly from\nthe client for services that allow this.\n\nUsers are by default allowed to specify their own `profile` field with\n[`Accounts.createUser`](#accounts_createuser) and modify it with\n`Meteor.users.update`. To allow users to edit additional fields, use\n[`Meteor.users.allow`](#allow). To forbid users from making any modifications to\ntheir user document:\n\n    Meteor.users.deny({update: function () { return true; }});\n\n\n",["#",[[0,"with"],[0,"loggingIn"]],[[">","api_box"]]],"\n\nFor example, [the `accounts-ui` package](#accountsui) uses this to display an\nanimation while the login request is being processed.\n\n",["#",[[0,"with"],[0,"logout"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"loginWithPassword"]],[[">","api_box"]]],"\n\nThis function is provided by the `accounts-password` package. See the\n[Passwords](#accounts_passwords) section below.\n\n\n",["#",[[0,"with"],[0,"loginWithExternalService"]],[[">","api_box"]]],"\n\nThese functions initiate the login process with an external\nservice (eg: Facebook, Google, etc), using OAuth. When called they open a new pop-up\nwindow that loads the provider's login page. Once the user has logged in\nwith the provider, the pop-up window is closed and the Meteor client\nlogs in to the Meteor server with the information provided by the external\nservice.\n\n<a id=\"requestpermissions\" name=\"requestpermissions\" />\n\nIn addition to identifying the user to your application, some services\nhave APIs that allow you to take action on behalf of the user. To\nrequest specific permissions from the user, pass the\n`requestPermissions` option the login function. This will cause the user\nto be presented with an additional page in the pop-up dialog to permit\naccess to their data. The user's `accessToken` &mdash; with permissions\nto access the service's API &mdash; is stored in the `services` field of\nthe user document. The supported values for `requestPermissions` differ\nfor each login service and are documented on their respective developer\nsites:\n\n- Facebook: <http://developers.facebook.com/docs/authentication/permissions/>\n- GitHub: <http://developer.github.com/v3/oauth/#scopes>\n- Google: <https://developers.google.com/accounts/docs/OAuth2Login#scopeparameter>\n- Meetup: <http://www.meetup.com/meetup_api/auth/#oauth2-scopes>\n- Twitter, Weibo: `requestPermissions` currently not supported\n\nExternal login services typically require registering and configuring\nyour application before use. The easiest way to do this is with the\n[`accounts-ui` package](#accountsui) which presents a step-by-step guide\nto configuring each service. However, the data can be also be entered\nmanually in the `Accounts.loginServiceConfiguration` collection. For\nexample:\n\n    // first, remove configuration entry in case service is already configured\n    Accounts.loginServiceConfiguration.remove({\n      service: \"weibo\"\n    });\n    Accounts.loginServiceConfiguration.insert({\n      service: \"weibo\",\n      clientId: \"1292962797\",\n      secret: \"75a730b58f5691de5522789070c319bc\"\n    });\n\n\nEach external service has its own login provider package and login function. For\nexample, to support GitHub login, run `$ meteor add accounts-github` and use the\n`Meteor.loginWithGithub` function:\n\n    Meteor.loginWithGithub({\n      requestPermissions: ['user', 'public_repo']\n    }, function (err) {\n      if (err)\n        Session.set('errorMessage', err.reason || 'Unknown error');\n    });\n\n\n\n",["#",[[0,"with"],[0,"currentUser"]],[[">","api_box"]]],"\n",["#",[[0,"with"],[0,"loggingInTemplate"]],[[">","api_box"]]],"\n",["#",[[0,"with"],[0,"accounts_config"]],[[">","api_box"]]],"\n",["#",[[0,"with"],[0,"accounts_ui_config"]],[[">","api_box"]]],"\n\nExample:\n\n    Accounts.ui.config({\n      requestPermissions: {\n        facebook: ['user_likes'],\n        github: ['user', 'repo']\n      },\n      requestOfflineToken: {\n        google: true\n      },\n      passwordSignupFields: 'USERNAME_AND_OPTIONAL_EMAIL'\n    });\n\n",["#",[[0,"with"],[0,"accounts_validateNewUser"]],[[">","api_box"]]],"\n\nThis can be called multiple times. If any of the functions return `false` or\nthrow an error, the new user creation is aborted. To set a specific error\nmessage (which will be displayed by [`accounts-ui`](#accountsui)), throw a new\n[`Meteor.Error`](#meteor_error).\n\nExample:\n\n    // Validate username, sending a specific error message on failure.\n    Accounts.validateNewUser(function (user) {\n      if (user.username && user.username.length >= 3)\n        return true;\n      throw new Meteor.Error(403, \"Username must have at least 3 characters\");\n    });\n    // Validate username, without a specific error message.\n    Accounts.validateNewUser(function (user) {\n      return user.username !== \"root\";\n    });\n\n",["#",[[0,"with"],[0,"accounts_onCreateUser"]],[[">","api_box"]]],"\n\nUse this when you need to do more than simply accept or reject new user\ncreation. With this function you can programatically control the\ncontents of new user documents.\n\nThe function you pass will be called with two arguments: `options` and\n`user`. The `options` argument comes\nfrom [`Accounts.createUser`](#accounts_createuser) for\npassword-based users or from an external service login flow. `options` may come\nfrom an untrusted client so make sure to validate any values you read from\nit. The `user` argument is created on the server and contains a\nproposed user object with all the automatically generated fields\nrequired for the user to log in.\n\nThe function should return the user document (either the one passed in or a\nnewly-created object) with whatever modifications are desired. The returned\ndocument is inserted directly into the [`Meteor.users`](#meteor_users) collection.\n\nThe default create user function simply copies `options.profile` into\nthe new user document. Calling `onCreateUser` overrides the default\nhook. This can only be called once.\n\nExample:\n\n<!-- XXX replace d6 with _.random once we have underscore 1.4.2 -->\n\n    // Support for playing D&D: Roll 3d6 for dexterity\n    Accounts.onCreateUser(function(options, user) {\n      var d6 = function () { return Math.floor(Random.fraction() * 6) + 1; };\n      user.dexterity = d6() + d6() + d6();\n      // We still want the default hook's 'profile' behavior.\n      if (options.profile)\n        user.profile = options.profile;\n      return user;\n    });\n\n\n<h2 id=\"accounts_passwords\"><span>Passwords</span></h2>\n\nThe `accounts-password` package contains a full system for password-based\nauthentication. In addition to the basic username and password-based\nsign-in process, it also supports email-based sign-in including\naddress verification and password recovery emails.\n\nUnlike most web applications, the Meteor client does not send the user's\npassword directly to the server. It uses the [Secure Remote Password\nprotocol](http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol)\nto ensure the server never sees the user's plain-text password. This\nhelps protect against embarrassing password leaks if the server's\ndatabase is compromised.\n\nTo add password support to your application, run `$ meteor add\naccounts-password`. You can construct your own user interface using the\nfunctions below, or use the [`accounts-ui` package](#accountsui) to\ninclude a turn-key user interface for password-based sign-in.\n\n\n",["#",[[0,"with"],[0,"accounts_createUser"]],[[">","api_box"]]],"\n\nOn the client, this function logs in as the newly created user on\nsuccessful completion. On the server, it returns the newly created user\nid.\n\nOn the client, you must pass `password` and one of `username` or `email`\n&mdash; enough information for the user to be able to log in again\nlater. On the server, you can pass any subset of these options, but the\nuser will not be able to log in until it has an identifier and a\npassword.\n\nTo create an account without a password on the server and still let the\nuser pick their own password, call `createUser` with the `email` option\nand then\ncall [`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail). This\nwill send the user an email with a link to set their initial password.\n\nBy default the `profile` option is added directly to the new user document. To\noverride this behavior, use [`Accounts.onCreateUser`](#accounts_oncreateuser).\n\nThis function is only used for creating users with passwords. The external\nservice login flows do not use this function.\n\n\n",["#",[[0,"with"],[0,"accounts_changePassword"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"accounts_forgotPassword"]],[[">","api_box"]]],"\n\nThis triggers a call\nto [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail)\non the server. Pass the token the user receives in this email\nto [`Accounts.resetPassword`](#accounts_resetpassword) to\ncomplete the password reset process.\n\nIf you are using the [`accounts-ui` package](#accountsui), this is handled\nautomatically. Otherwise, it is your responsiblity to prompt the user for the\nnew password and call `resetPassword`.\n\n",["#",[[0,"with"],[0,"accounts_resetPassword"]],[[">","api_box"]]],"\n\nThis function accepts tokens generated\nby [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail)\nand\n[`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail).\n\n",["#",[[0,"with"],[0,"accounts_setPassword"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"accounts_verifyEmail"]],[[">","api_box"]]],"\n\nThis function accepts tokens generated\nby [`Accounts.sendVerificationEmail`](#accounts_sendverificationemail). It\nsets the `emails.verified` field in the user record.\n\n",["#",[[0,"with"],[0,"accounts_sendResetPasswordEmail"]],[[">","api_box"]]],"\n\nThe token in this email should be passed\nto [`Accounts.resetPassword`](#accounts_resetpassword).\n\nTo customize the contents of the email, see\n[`Accounts.emailTemplates`](#accounts_emailtemplates).\n\n",["#",[[0,"with"],[0,"accounts_sendEnrollmentEmail"]],[[">","api_box"]]],"\n\nThe token in this email should be passed\nto [`Accounts.resetPassword`](#accounts_resetpassword).\n\nTo customize the contents of the email, see\n[`Accounts.emailTemplates`](#accounts_emailtemplates).\n\n",["#",[[0,"with"],[0,"accounts_sendVerificationEmail"]],[[">","api_box"]]],"\n\nThe token in this email should be passed\nto [`Accounts.verifyEmail`](#accounts_verifyemail).\n\nTo customize the contents of the email, see\n[`Accounts.emailTemplates`](#accounts_emailtemplates).\n\n",["#",[[0,"with"],[0,"accounts_emailTemplates"]],[[">","api_box"]]],"\n\nThis is an `Object` with several fields that are used to generate text\nfor the emails sent by `sendResetPasswordEmail`, `sendEnrollmentEmail`,\nand `sendVerificationEmail`.\n\nOverride fields of the object by assigning to them:\n\n- `from`: A `String` with an [RFC5322](http://tools.ietf.org/html/rfc5322) From\n   address. By default, the email is sent from `no-reply@meteor.com`. If you\n   wish to receive email from users asking for help with their account, be sure\n   to set this to an email address that you can receive email at.\n- `siteName`: The public name of your application. Defaults to the DNS name of\n   the application (eg: `awesome.meteor.com`).\n- `resetPassword`: An `Object` with two fields:\n - `resetPassword.subject`: A `Function` that takes a user object and returns\n   a `String` for the subject line of a reset password email.\n - `resetPassword.text`: A `Function` that takes a user object and a url, and\n   returns the body text for a reset password email.\n- `enrollAccount`: Same as `resetPassword`, but for initial password setup for\n   new accounts.\n- `verifyEmail`: Same as `resetPassword`, but for verifying the users email\n   address.\n\n\nExample:\n\n    Accounts.emailTemplates.siteName = \"AwesomeSite\";\n    Accounts.emailTemplates.from = \"AwesomeSite Admin <accounts@example.com>\";\n    Accounts.emailTemplates.enrollAccount.subject = function (user) {\n        return \"Welcome to Awesome Town, \" + user.profile.name;\n    };\n    Accounts.emailTemplates.enrollAccount.text = function (user, url) {\n       return \"You have been selected to participate in building a better future!\"\n         + \" To activate your account, simply click the link below:\\n\\n\"\n         + url;\n    };\n\n\n<h2 id=\"templates_api\"><span>Templates</span></h2>\n\nA template that you declare as `<","template name=\"foo\"> ... </","template>` can be accessed as the function `Template.foo`, which\nreturns a string of HTML when called.\n\nThe same template may occur many times on the page, and these\noccurrences are called template instances.  Template instances have a\nlife cycle of being created, put into the document, and later taken\nout of the document and destroyed.  Meteor manages these stages for\nyou, including determining when a template instance has been removed\nor replaced and should be cleaned up.  You can associate data with a\ntemplate instance, and you can access its DOM nodes when it is in the\ndocument.\n\nAdditionally, Meteor will maintain a template instance and its state\neven if its surrounding HTML is re-rendered into new DOM nodes.  As\nlong as the structure of template invocations is the same, Meteor will\nnot consider any instances to have been created or destroyed.  You can\nrequest that the same DOM nodes be retained as well using `preserve`\nand `constant`.\n\nThere are a number of callbacks and directives that you can specify on\na named template and that apply to all instances of the template.\nThey are described below.\n\n",["#",[[0,"with"],[0,"template_call"]],[[">","api_box"]]],"\n\nWhen called inside a template helper, the body of `Meteor.render`, or\nother settings where reactive HTML is being generated, the resulting\nHTML is annotated so that it renders as reactive DOM elements.\nOtherwise, the HTML is unadorned and static.\n\n\n",["#",[[0,"with"],[0,"template_rendered"]],[[">","api_box"]]],"\n\nThis callback is called once when an instance of Template.*myTemplate* is\nrendered into DOM nodes and put into the document for the first time, and again\neach time any part of the template is re-rendered.\n\nIn the body of the callback, `this` is a [template\ninstance](#template_inst) object that is unique to this occurrence of\nthe template and persists across re-renderings.  Use the `created` and\n`destroyed` callbacks to perform initialization or clean-up on the\nobject.\n\n",["#",[[0,"with"],[0,"template_created"]],[[">","api_box"]]],"\n\nThis callback is called when an invocation of *myTemplate* represents\na new occurrence of the template and not a re-rendering of an existing\ntemplate instance.  Inside the callback, `this` is the new [template\ninstance](#template_inst) object.  Properties you set on this object\nwill be visible from the `rendered` and `destroyed` callbacks and from\nevent handlers.\n\nThis callback fires once and is the first callback to fire.  Every\n`created` has a corresponding `destroyed`; that is, if you get a\n`created` callback with a certain template instance object in `this`,\nyou will eventually get a `destroyed` callback for the same object.\n\n",["#",[[0,"with"],[0,"template_destroyed"]],[[">","api_box"]]],"\n\nThis callback is called when an occurrence of a template is taken off\nthe page for any reason and not replaced with a re-rendering.  Inside\nthe callback, `this` is the [template instance](#template_inst) object\nbeing destroyed.\n\nThis callback is most useful for cleaning up or undoing any external\neffects of `created`.  It fires once and is the last callback to fire.\n\n\n",["#",[[0,"with"],[0,"template_events"]],[[">","api_box"]]],"\n\nDeclare event handers for instances of this template. Multiple calls add\nnew event handlers in addition to the existing ones.\n\nSee [Event Maps](#eventmaps) for a detailed description of the event\nmap format and how event handling works in Meteor.\n\n",["#",[[0,"with"],[0,"template_helpers"]],[[">","api_box"]]],"\n\nEach template has a local dictionary of helpers that are made available to it,\nand this call specifies helpers to add to the template's dictionary.\n\nExample:\n\n    Template.myTemplate.helpers({\n      foo: function () {\n        return Session.get(\"foo\");\n      }\n    });\n\nIn Handlebars, this helper would then be invoked as `",["{",[[0,"dstache"]]],"foo}}`.\n\nThe following syntax is equivalent, but won't work for reserved property\nnames:\n\n    Template.myTemplate.foo = function () {\n      return Session.get(\"foo\");\n    };\n\n",["#",[[0,"with"],[0,"template_preserve"]],[[">","api_box"]]],"\n\nYou can \"preserve\" a DOM element during re-rendering, leaving the\nexisting element in place in the document while replacing the\nsurrounding HTML.  This means that re-rendering a template need not\ndisturb text fields, iframes, and other sensitive elements it\ncontains.  The elements to preserve must be present both as nodes in\nthe old DOM and as tags in the new HTML.  Meteor will patch the DOM\naround the preserved elements.\n\n",["#",[[0,"note"]],["\nBy default, new Meteor apps automatically include the\n`preserve-inputs` package.  This preserves all elements of type\n`input`, `textarea`, `button`, `select`, and `option` that have unique\n`id` attributes or that have `name` attributes that are unique within\nan enclosing element with an `id` attribute.  To turn off this default\nbehavior, simply remove the `preserve-inputs` package.\n"]],"\n\nPreservation is useful in a variety of cases where replacing a DOM\nelement with an identical or modified element would not have the same\neffect as retaining the original element.  These include:\n\n* Input text fields and other form controls\n* Elements with CSS animations\n* Iframes\n* Nodes with references kept in JavaScript code\n\nIf you want to preserve a whole region of the DOM, an element and its\nchildren, or nodes not rendered by Meteor, use a [constant\nregion](#constant) instead.\n\nTo preserve nodes, pass a list of selectors, each of which should match\nat most one element in the template.  When the template is re-rendered,\nthe selector is run on the old DOM and the new DOM, and Meteor will\nreuse the old element in place while working in any HTML changes around\nit.\n\nA second form of `preserve` takes a labeling function for each selector\nand allows the selectors to match multiple nodes. The node-labeling\nfunction takes a node and returns a label string that is unique for each\nnode, or `false` to exclude the node from preservation.\n\nFor example, to preserve all `<input>` elements with ids in template 'foo', use:\n\n    Template.foo.preserve({\n      'input[id]': function (node) { return node.id; }\n    });\n\nSelectors are interpreted as rooted at the top level of the template.\nEach occurrence of the template operates independently, so the selectors\ndo not have to be unique on the entire page, only within one occurrence\nof the template.  Selectors will match nodes even if they are in\nsub-templates.\n\nPreserving a node does *not* preserve its attributes or contents. They\nwill be updated to reflect the new HTML. Text in input fields is not\npreserved unless the input field has focus, in which case the cursor and\nselection are left intact. Iframes retain their navigation state and\nanimations continue to run as long as their parameters haven't changed.\n\nThere are some cases where nodes can not be preserved because of\nconstraints inherent in the DOM API. For example, an element's tag name\ncan't be changed, and it can't be moved relative to its parent or other\npreserved nodes.  For this reason, nodes that are re-ordered or\nre-parented by an update will not be preserved.\n\n",["#",[[0,"note"]],["\nPrevious versions of Meteor had an implicit page-wide `preserve`\ndirective that labeled nodes by their \"id\" and \"name\" attributes.\nThis has been removed in favor of the explicit, opt-in mechanism.\n"]],"\n\n\n<h2 id=\"template_inst\"><span>Template instances</span></h2>\n\nA template instance object represents an occurrence of a template in\nthe document.  It can be used to access the DOM and it can be\nassigned properties that persist across page re-renderings.\n\nTemplate instance objects are found as the value of `this` in the\n`created`, `rendered`, and `destroyed` template callbacks and as an\nargument to event handlers.\n\nIn addition to the properties and functions described below, you can\nassign additional properties of your choice to the object.  Property names\nstarting with `_` are guaranteed to be available for your use.  Use\nthe `created` and `destroyed` callbacks to perform initialization or\nclean-up on the object.\n\nYou can only access `findAll`, `find`, `firstNode`, and `lastNode`\nfrom the `rendered` callback and event handlers, not from `created`\nand `destroyed`, because they require the template instance to be\nin the DOM.\n\n",["#",[[0,"with"],[0,"template_findAll"]],[[">","api_box"]]],"\n\nReturns an array of DOM elements matching `selector`.\n\nThe template instance serves as the document root for the selector. Only\nelements inside the template and its sub-templates can match parts of\nthe selector.\n\n",["#",[[0,"with"],[0,"template_find"]],[[">","api_box"]]],"\n\nReturns one DOM element matching `selector`, or `null` if there are no\nsuch elements.\n\nThe template instance serves as the document root for the selector. Only\nelements inside the template and its sub-templates can match parts of\nthe selector.\n\n",["#",[[0,"with"],[0,"template_firstNode"]],[[">","api_box"]]],"\n\nThe two nodes `firstNode` and `lastNode` indicate the extent of the\nrendered template in the DOM.  The rendered template includes these\nnodes, their intervening siblings, and their descendents.  These two\nnodes are siblings (they have the same parent), and `lastNode` comes\nafter `firstNode`, or else they are the same node.\n\n",["#",[[0,"with"],[0,"template_lastNode"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"template_data"]],[[">","api_box"]]],"\n\nThis property provides access to the data context at the top level of\nthe template.  It is updated each time the template is re-rendered.\nAccess is read-only and non-reactive.\n\n\n",["#",[[0,"with"],[0,"render"]],[[">","api_box"]]],"\n\n`Meteor.render` creates a `DocumentFragment` (a sequence of DOM nodes)\nthat automatically updates in realtime. Most Meteor apps don't need to\ncall this directly; they use templates and Meteor handles the rendering.\n\nPass in `htmlFunc`, a function that returns an HTML\nstring. `Meteor.render` calls the function and turns the output into\nDOM nodes. Meanwhile, it tracks the data that was used when `htmlFunc`\nran, and automatically wires up callbacks so that whenever any of the\ndata changes, `htmlFunc` is re-run and the DOM nodes are updated in\nplace.\n\nYou may insert the returned `DocumentFragment` directly into the DOM\nwherever you would like it to appear. The inserted nodes will continue\nto update until they are taken off the screen. Then they will be\nautomatically cleaned up. For more details about clean-up, see\n[`Deps.flush`](#deps_flush).\n\n`Meteor.render` tracks the data dependencies of `htmlFunc` by running\nit in a reactive computation, so it can respond to changes in any reactive\ndata sources used by that function. For more information, or to learn\nhow to make your own reactive data sources, see\n[Reactivity](#reactivity).\n\nExample:\n\n    // Client side: show the number of players online.\n    var frag = Meteor.render(function () {\n      return \"<p>There are \" + Players.find({online: true}).count() +\n        \" players online.</p>\";\n    });\n    document.body.appendChild(frag);\n\n    // Server side: find all players that have been idle for a while,\n    // and mark them as offline. The count on the screen will\n    // automatically update on all clients.\n    Players.update({idleTime: {$gt: 30}}, {$set: {online: false}});\n\n",["#",[[0,"with"],[0,"renderList"]],[[">","api_box"]]],"\n\nCreates a `DocumentFragment` that automatically updates as the results\nof a database query change. Most Meteor apps use `",["{",[[0,"dstache"]]],"#each}}` in\na template instead of calling this directly.\n\n`renderList` is more efficient than using `Meteor.render` to render HTML\nfor a list of documents.  For example, if a new document is created in\nthe database that matches the query, a new item will be rendered and\ninserted at the appropriate place in the DOM without re-rendering the\nother elements.  Similarly, if a document changes position in a sorted\nquery, the DOM nodes will simply be moved and not re-rendered.\n\n`docFunc` is called as needed to generate HTML for each document.  If\nyou provide `elseFunc`, then whenever the query returns no results, it\nwill be called to render alternate content. You might use this to show\na message like \"No records match your query.\"\n\nEach call to `docFunc` or `elseFunc` is run in its own reactive\ncomputation so that if it has other external data dependencies, it will be\nindividually re-run when the data changes.\n\nExample:\n\n    // List the titles of all of the posts that have the tag\n    // \"frontpage\". Keep the list updated as new posts are made, as tags\n    // change, etc.  Display the selected post differently.\n    var frag = Meteor.renderList(\n      Posts.find({tags: \"frontpage\"}),\n      function(post) {\n        var style = Session.equals(\"selectedId\", post._id) ? \"selected\" : \"\";\n        // A real app would need to quote/sanitize post.name\n        return '<div class=\"' + style + '\">' + post.name + '</div>';\n      });\n    document.body.appendChild(frag);\n\n    // Select a post.  This will cause only the selected item and the\n    // previously selected item to update.\n    var somePost = Posts.findOne({tags: \"frontpage\"});\n    Session.set(\"selectedId\", somePost._id);\n\n\n",["#",[[0,"api_box_inline"],[0,"eventmaps"]],["\n\nSeveral functions take event maps. An event map is an object where\nthe properties specify a set of events to handle, and the values are\nthe handlers for those events. The property can be in one of several\nforms:\n\n<dl>\n",["#",[[0,"dtdd"],"<em>eventtype</em>"],["\nMatches a particular type of event, such as 'click'.\n"]],"\n\n",["#",[[0,"dtdd"],"<em>eventtype selector</em>"],["\nMatches a particular type of event, but only when it appears on\nan element that matches a certain CSS selector.\n"]],"\n\n",["#",[[0,"dtdd"],"<em>event1, event2</em>"],["\nTo handle more than one type of event with the same function, use a\ncomma-separated list.\n"]],"\n</dl>\n\nThe handler function receives two arguments: `event`, an object with\ninformation about the event, and `template`, a [template\ninstance](#template_inst) for the template where the handler is\ndefined.  The handler also receives some additional context data in\n`this`, depending on the context of the current element handling the\nevent.  In a Handlebars template, an element's context is the\nHandlebars data context where that element occurs, which is set by\nblock helpers such as `#with` and `#each`.\n\nExample:\n\n    {\n      // Fires when any element is clicked\n      'click': function (event) { ... },\n\n      // Fires when any element with the 'accept' class is clicked\n      'click .accept': function (event) { ... },\n\n      // Fires when 'accept' is clicked, or a key is pressed\n      'keydown, click .accept': function (event) { ... }\n    }\n\nMost events bubble up the document tree from their originating\nelement.  For example, `'click p'` catches a click anywhere in a\nparagraph, even if the click originated on a link, span, or some other\nelement inside the paragraph.  The originating element of the event\nis available as the `target` property, while the element that matched\nthe selector and is currently handling it is called `currentTarget`.\n\n    {\n      'click p': function (event) {\n        var paragraph = event.currentTarget; // always a P\n        var clickedElement = event.target; // could be the P or a child element\n      }\n    }\n\nIf a selector matches multiple elements that an event bubbles to, it\nwill be called multiple times, for example in the case of `'click\ndiv'` or `'click *'`.  If no selector is given, the handler\nwill only be called once, on the original target element.\n\nThe following properties and methods are available on the event object\npassed to handlers:\n\n<dl class=\"objdesc\">\n",["#",[[0,"dtdd"],{"name":"type","type":"String"}],["\nThe event's type, such as \"click\", \"blur\" or \"keypress\".\n"]],"\n\n",["#",[[0,"dtdd"],{"name":"target","type":"DOM Element"}],["\nThe element that originated the event.\n"]],"\n\n",["#",[[0,"dtdd"],{"name":"currentTarget","type":"DOM Element"}],["\nThe element currently handling the event.  This is the element that\nmatched the selector in the event map.  For events that bubble, it may\nbe `target` or an ancestor of `target`, and its value changes as the\nevent bubbles.\n"]],"\n\n",["#",[[0,"dtdd"],{"name":"which","type":"Number"}],["\nFor mouse events, the number of the mouse button (1=left, 2=middle, 3=right).\nFor key events, a character or key code.\n"]],"\n\n",["#",[[0,"dtdd"],"stopPropagation()"],["\nPrevent the event from propagating (bubbling) up to other elements.\nOther event handlers matching the same element are still fired, in\nthis and other event maps.\n"]],"\n\n",["#",[[0,"dtdd"],"stopImmediatePropagation()"],["\nPrevent all additional event handlers from being run on this event,\nincluding other handlers in this event map, handlers reached by\nbubbling, and handlers in other event maps.\n"]],"\n\n",["#",[[0,"dtdd"],"preventDefault()"],["\nPrevents the action the browser would normally take in response to this\nevent, such as following a link or submitting a form.  Further handlers\nare still called, but cannot reverse the effect.\n"]],"\n\n",["#",[[0,"dtdd"],"isPropagationStopped()"],["\nReturns whether `stopPropagation()` has been called for this event.\n"]],"\n\n",["#",[[0,"dtdd"],"isImmediatePropagationStopped()"],["\nReturns whether `stopImmediatePropagation()` has been called for this event.\n"]],"\n\n",["#",[[0,"dtdd"],"isDefaultPrevented()"],["\nReturns whether `preventDefault()` has been called for this event.\n"]],"\n</dl>\n\nReturning `false` from a handler is the same as calling\nboth `stopImmediatePropagation` and `preventDefault` on the event.\n\nEvent types and their uses include:\n\n<dl class=\"objdesc\">\n",["#",[[0,"dtdd"],"<code>click</code>"],["\nMouse click on any element, including a link, button, form control, or div.\nUse `preventDefault()` to prevent a clicked link from being followed.\nSome ways of activating an element from the keyboard also fire `click`.\n"]],"\n\n",["#",[[0,"dtdd"],"<code>dblclick</code>"],["\nDouble-click.\n"]],"\n\n",["#",[[0,"dtdd"],"<code>focus, blur</code>"],["\nA text input field or other form control gains or loses focus.  You\ncan make any element focusable by giving it a `tabindex` property.\nBrowsers differ on whether links, checkboxes, and radio buttons are\nnatively focusable.  These events do not bubble.\n"]],"\n\n",["#",[[0,"dtdd"],"<code>change</code>"],["\nA checkbox or radio button changes state.  For text fields, use\n`blur` or key events to respond to changes.\n"]],"\n\n",["#",[[0,"dtdd"],"<code>mouseenter, mouseleave</code>"],[" The pointer enters or\nleaves the bounds of an element.  These events do not bubble.\n"]],"\n\n",["#",[[0,"dtdd"],"<code>mousedown, mouseup</code>"],["\nThe mouse button is newly down or up.\n"]],"\n\n",["#",[[0,"dtdd"],"<code>keydown, keypress, keyup</code>"],["\nThe user presses a keyboard key.  `keypress` is most useful for\ncatching typing in text fields, while `keydown` and `keyup` can be\nused for arrow keys or modifier keys.\n"]],"\n\n",["#",[[0,"dtdd"],"<code>tap</code>"],[" Tap on an element.  On touch-enabled\ndevices, this is a replacement to `click` that fires immediately.\nThese events are synthesized from `touchmove` and `touchend`.\n"]],"\n\n</dl>\n\nOther DOM events are available as well, but for the events above,\nMeteor has taken some care to ensure that they work uniformly in all\nbrowsers.\n\n"]],"\n\n\n\n",["#",[[0,"api_box_inline"],[0,"constant"]],["\n\nYou can mark a region of a template as \"constant\" and not subject to\nre-rendering using the\n`",["{",[[0,"dstache"]]],"#constant}}...",["{",[[0,"dstache"]]],"/constant}}` block helper.\nContent inside the `#constant` block helper is preserved exactly as-is\neven if the enclosing template is re-rendered.  Changes to other parts\nof the template are patched in around it in the same manner as\n`preserve`.  Unlike individual node preservation, a constant region\nretains not only the identities of its nodes but also their attributes\nand contents.  The contents of the block will only be evaluated once\nper occurrence of the enclosing template.\n\nConstant regions allow non-Meteor content to be embedded in a Meteor\ntemplate.  Many third-party widgets create and manage their own DOM\nnodes programmatically. Typically, you put an empty element in your\ntemplate, which the widget or library will then populate with\nchildren. Normally, when Meteor re-renders the enclosing template it\nwould remove the new children, since the template says it should be\nempty. If the container is wrapped in a `#constant` block, however, it\nis left alone; whatever content is currently in the DOM remains.\n\n",["#",[[0,"note"]],["\nConstant regions are intended for embedding non-Meteor content.\nEvent handlers and reactive dependencies don't currently work\ncorrectly inside constant regions.\n"]],"\n\n\n"]],"\n\n",["#",[[0,"api_box_inline"],[0,"isolate"]],["\n\nEach template runs as its own reactive computation.  When the template\naccesses a reactive data source, such as by calling `Session.get` or\nmaking a database query, this establishes a data dependency that will\ncause the whole template to be re-rendered when the data changes.\nThis means that the amount of re-rendering for a particular change\nis affected by how you've divided your HTML into templates.\n\nTypically, the exact extent of re-rendering is not crucial, but if you\nwant more control, such as for performance reasons, you can use the\n`",["{",[[0,"dstache"]]],"#isolate}}...",["{",[[0,"dstache"]]],"/isolate}}` helper.  Data\ndependencies established inside an `#isolate` block are localized to\nthe block and will not in themselves cause the parent template to be\nre-rendered.  This block helper essentially conveys the reactivity\nbenefits you would get by pulling the content out into a new\nsub-template.\n\n"]],"\n\n<h2 id=\"match\"><span>Match</span></h2>\n\nMeteor methods and publish functions take arbitrary [EJSON](#ejson) types as\narguments, but most arguments are expected to be of a particular type. Meteor's\n`check` package is a lightweight library for checking that arguments and other\nvalues are of the expected type. For example:\n\n    Meteor.publish(\"chats-in-room\", function (roomId) {\n      // Make sure roomId is a string, not an arbitrary mongo selector object.\n      check(roomId, String);\n      return Chats.find({room: roomId});\n    });\n\n    Meteor.methods({addChat: function (roomId, message) {\n      check(roomId, String);\n      check(message, {\n        text: String,\n        timestamp: Date,\n        // Optional, but if present must be an array of strings.\n        tags: Match.Optional([String])\n      });\n\n      // ... do something with the message ...\n    }});\n\n",["#",[[0,"with"],[0,"check"]],[[">","api_box"]]],"\n\nIf the match fails, `check` throws a `Match.Error` describing how it failed. If\nthis error gets sent over the wire to the client, it will appear only as\n`Meteor.Error(400, \"Match Failed\")`; the failure details will be written to the\nserver logs but not revealed to the client.\n\n",["#",[[0,"with"],[0,"match_test"]],[[">","api_box"]]],"\n\n",["#",[[0,"api_box_inline"],[0,"matchpatterns"]],["\n\nThe following patterns can be used as pattern arguments to `check` and `Match.test`:\n\n\n<dl>\n",["#",[[0,"dtdd"],"<code>Match.Any</code>"],["\nMatches any value.\n"]],"\n\n",["#",[[0,"dtdd"],"<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>undefined</code>, <code>null</code>"],["\nMatches a primitive of the given type.\n"]],"\n\n",["#",[[0,"dtdd"],"<code>Match.Integer</code>"],["\nMatches a signed 32-bit integer. Doesn't match `Infinity`, `-Infinity`, or `NaN`.\n"]],"\n\n",["#",[[0,"dtdd"],"<code>[<em>pattern</em>]</code>"],["\nA one-element array matches an array of elements, each of which match\n*pattern*. For example, `[Number]` matches a (possibly empty) array of numbers;\n`[Match.Any]` matches any array.\n"]],"\n\n",["#",[[0,"dtdd"],"<code>{<em>key1</em>: <em>pattern1</em>, <em>key2</em>: <em>pattern2</em>, ...}</code>"],["\nMatches an Object with the given keys, with values matching the given patterns.\nIf any *pattern* is a `Match.Optional`, that key does not need to exist\nin the object. The value may not contain any keys not listed in the pattern.\nThe value must be a plain Object with no special prototype.\n"]],"\n\n",["#",[[0,"dtdd"],"<code>Match.ObjectIncluding({<em>key1</em>: <em>pattern1</em>, <em>key2</em>: <em>pattern2</em>, ...})</code>"],["\nMatches an Object with the given keys; the value may also have other keys\nwith arbitrary values.\n"]],"\n\n",["#",[[0,"dtdd"],"<code>Object</code>"],["\nMatches any plain Object with any keys; equivalent to\n`Match.ObjectIncluding({})`.\n"]],"\n\n",["#",[[0,"dtdd"],"<code>Match.Optional(<em>pattern</em>)</code>"],[" Matches either\n`undefined` or something that matches pattern. If used in an object this matches\nonly if the key is not set as opposed to the value being set to `undefined`.\n\n    // In an object\n    var pat = { name: Match.Optional(String) };\n    check({ name: \"something\" }, pat) // OK\n    check({}, pat) // OK\n    check({ name: undefined }, pat) // Throws an exception\n\n    // Outside an object\n    check(undefined, Match.Optional(String)); // OK\n\n"]],"\n\n",["#",[[0,"dtdd"],"<code>Match.OneOf(<em>pattern1</em>, <em>pattern2</em>, ...)</code>"],["\nMatches any value that matches at least one of the provided patterns.\n"]],"\n\n",["#",[[0,"dtdd"],"Any constructor function (eg, <code>Date</code>)"],["\nMatches any element that is an instance of that type.\n"]],"\n\n",["#",[[0,"dtdd"],"<code>Match.Where(<em>condition</em>)</code>"],["\nCalls the function *condition* with the value as the argument. If *condition*\nreturns true, this matches. If *condition* throws a `Match.Error` or returns\nfalse, this fails. If *condition* throws any other error, that error is thrown\nfrom the call to `check` or `Match.test`. Examples:\n\n    check(buffer, Match.Where(EJSON.isBinary));\n\n    NonEmptyString = Match.Where(function (x) {\n      check(x, String);\n      return x.length > 0;\n    });\n    check(arg, NonEmptyString);\n"]],"\n</dl>\n\n"]],"\n\n<h2 id=\"timers\"><span>Timers</span></h2>\n\nMeteor uses global environment variables\nto keep track of things like the current request's user.  To make sure\nthese variables have the right values, you need to use\n`Meteor.setTimeout` instead of `setTimeout` and `Meteor.setInterval`\ninstead of `setInterval`.\n\nThese functions work just like their native JavaScript equivalents.\nYou'll get an error if you call the native function.\n\n",["#",[[0,"with"],[0,"setTimeout"]],[[">","api_box"]]],"\n\nReturns a handle that can be used by `Meteor.clearTimeout`.\n\n",["#",[[0,"with"],[0,"setInterval"]],[[">","api_box"]]],"\n\nReturns a handle that can be used by `Meteor.clearInterval`.\n\n",["#",[[0,"with"],[0,"clearTimeout"]],[[">","api_box"]]],"\n",["#",[[0,"with"],[0,"clearInterval"]],[[">","api_box"]]],"\n\n<h2 id=\"deps\"><span>Deps</span></h2>\n\nMeteor has a simple dependency tracking system which allows it to\nautomatically rerun templates and other computations whenever\n[`Session`](#session) variables, database queries, and other data\nsources change.\n\nUnlike most other systems, you don't have to manually declare these\ndependencies &mdash; it \"just works\". The mechanism is simple and\nefficient. When you call a function that supports reactive updates\n(such as a database query), it automatically saves the current\nComputation object, if any (representing, for example, the current\ntemplate being rendered).  Later, when the data changes, the function\ncan \"invalidate\" the Computation, causing it to rerun (rerendering the\ntemplate).\n\nApplications will find [`Deps.autorun`](#deps_autorun) useful, while more\nadvanced facilities such as `Deps.Dependency` and `onInvalidate`\ncallbacks are intended primarily for package authors implementing new\nreactive data sources.\n\n",["#",[[0,"with"],[0,"deps_autorun"]],[[">","api_box"]]],"\n\n`Deps.autorun` allows you to run a function that depends on reactive data\nsources, in such a way that if there are changes to the data later,\nthe function will be rerun.\n\nFor example, you can monitor a cursor (which is a reactive data\nsource) and aggregate it into a session variable:\n\n    Deps.autorun(function () {\n      var oldest = _.max(Monkeys.find().fetch(), function (monkey) {\n        return monkey.age;\n      });\n      if (oldest)\n        Session.set(\"oldest\", oldest.name);\n    });\n\nOr you can wait for a session variable to have a certain value, and do\nsomething the first time it does, calling `stop` on the computation to\nprevent further rerunning:\n\n    Deps.autorun(function (c) {\n      if (! Session.equals(\"shouldAlert\", true))\n        return;\n\n      c.stop();\n      alert(\"Oh no!\");\n    });\n\nThe function is invoked immediately, at which point it may alert and\nstop right away if `shouldAlert` is already true.  If not, the\nfunction is run again when `shouldAlert` becomes true.\n\nA change to a data dependency does not cause an immediate rerun, but\nrather \"invalidates\" the computation, causing it to rerun the next\ntime a flush occurs.  A flush will occur automatically as soon as\nthe system is idle if there are invalidated computations.  You can\nalso use [`Deps.flush`](#deps_flush) to cause an immediate flush of\nall pending reruns.\n\nIf you nest calls to `Deps.autorun`, then when the outer call stops or\nreruns, the inner call will stop automatically.  Subscriptions and\nobservers are also automatically stopped when used as part of a\ncomputation that is rerun, allowing new ones to be established.  See\n[`Meteor.subscribe`](#meteor_subscribe) for more information about\nsubscriptions and reactivity.\n\nIf the initial run of an autorun throws an exception, the computation\nis automatically stopped and won't be rerun.\n\n",["#",[[0,"with"],[0,"deps_flush"]],[[">","api_box"]]],"\n\nNormally, when you make changes (like writing to the database),\ntheir impact (like updating the DOM) is delayed until the system is\nidle. This keeps things predictable &mdash; you can know that the DOM\nwon't go changing out from under your code as it runs. It's also one\nof the things that makes Meteor fast.\n\n`Deps.flush` forces all of the pending reactive updates to complete.\nFor example, if an event handler changes a Session\nvariable that will cause part of the user interface to rerender, the\nhandler can call `flush` to perform the rerender immediately and then\naccess the resulting DOM.\n\nAn automatic flush occurs whenever the system is idle which performs\nexactly the same work as `Deps.flush`.  The flushing process consists\nof rerunning any invalidated computations.  If additional\ninvalidations happen while flushing, they are processed as part of the\nsame flush until there is no more work to be done.  Callbacks\nregistered with [`Meteor.afterFlush`](#deps_afterflush) are called\nafter processing outstanding invalidations.\n\nAny auto-updating DOM elements that are found to not be in the\ndocument during a flush may be cleaned up by Meteor (meaning that\nMeteor will stop tracking and updating the elements, so that the\nbrowser's garbage collector can delete them).  So, if you manually\ncall `flush`, you need to make sure that any auto-updating elements\nthat you have created by calling [`Meteor.render`](#meteor_render)\nhave already been inserted in the main DOM tree.\n\nIt is illegal to call `flush` from inside a `flush` or from a running\ncomputation.\n\n",["#",[[0,"with"],[0,"deps_nonreactive"]],[[">","api_box"]]],"\n\nCalls `func()` with `Deps.currentComputation` temporarily set to\n`null`.  If `func` accesses reactive data sources, these data sources\nwill never cause a rerun of the enclosing computation.\n\n",["#",[[0,"with"],[0,"deps_active"]],[[">","api_box"]]],"\n\nThis value is useful for data source implementations to determine\nwhether they are being accessed reactively or not.\n\n",["#",[[0,"with"],[0,"deps_currentcomputation"]],[[">","api_box"]]],"\n\nIt's very rare to need to access `currentComputation` directly.  The\ncurrent computation is used implicitly by\n[`Deps.active`](#deps_active) (which tests whether there is one),\n[`dependency.depend()`](#dependency_depend) (which registers that it depends on a\ndependency), and [`Deps.onInvalidate`](#deps_oninvalidate) (which\nregisters a callback with it).\n\n",["#",[[0,"with"],[0,"deps_oninvalidate"]],[[">","api_box"]]],"\n\nSee [*`computation`*`.onInvalidate`](#computation_oninvalidate) for more\ndetails.\n\n",["#",[[0,"with"],[0,"deps_afterflush"]],[[">","api_box"]]],"\n\nFunctions scheduled by multiple calls to `afterFlush` are guaranteed\nto run in the order that `afterFlush` was called.  Functions are\nguaranteed to be called at a time when there are no invalidated\ncomputations that need rerunning.  This means that if an `afterFlush`\nfunction invalidates a computation, that computation will be rerun\nbefore any other `afterFlush` functions are called.\n\n<h2 id=\"deps_computation\"><span>Deps.Computation</span></h2>\n\nA Computation object represents code that is repeatedly rerun in\nresponse to reactive data changes.  Computations don't have return\nvalues; they just perform actions, such as rerendering a template on\nthe screen.  Computations are created using [`Deps.autorun`](#deps_autorun).\nUse [`stop`](#computation_stop) to prevent further rerunning of a\ncomputation.\n\nEach time a computation runs, it may access various reactive data\nsources that serve as inputs to the computation, which are called its\ndependencies.  At some future time, one of these dependencies may\ntrigger the computation to be rerun by invalidating it.  When this\nhappens, the dependencies are cleared, and the computation is\nscheduled to be rerun at flush time.\n\nThe *current computation*\n([`Deps.currentComputation`](#deps_currentcomputation)) is the\ncomputation that is currently being run or rerun (computed), and the\none that gains a dependency when a reactive data source is accessed.\nData sources are responsible for tracking these dependencies using\n[`Deps.Dependency`](#deps_dependency) objects.\n\nInvalidating a computation sets its `invalidated` property to true\nand immediately calls all of the computation's `onInvalidate`\ncallbacks.  When a flush occurs, if the computation has been invalidated\nand not stopped, then the computation is rerun by setting the\n`invalidated` property to `false` and calling the original function\nthat was passed to `Deps.autorun`.  A flush will occur when the current\ncode finishes running, or sooner if `Deps.flush` is called.\n\nStopping a computation invalidates it (if it is valid) for the purpose\nof calling callbacks, but ensures that it will never be rerun.\n\nExample:\n\n    // if we're in a computation, then perform some clean-up\n    // when the current computation is invalidated (rerun or\n    // stopped)\n    if (Deps.active) {\n      Deps.onInvalidate(function () {\n        x.destroy();\n        y.finalize();\n      });\n    }\n\n",["#",[[0,"with"],[0,"computation_stop"]],[[">","api_box"]]],"\n\nStopping a computation is irreversible and guarantees that it will\nnever be rerun.  You can stop a computation at any time, including\nfrom the computation's own run function.  Stopping a computation that\nis already stopped has no effect.\n\nStopping a computation causes its `onInvalidate` callbacks to run\nimmediately if it is not currently invalidated.\n\nNested computations are stopped automatically when their enclosing\ncomputation is rerun.\n\n",["#",[[0,"with"],[0,"computation_invalidate"]],[[">","api_box"]]],"\n\nInvalidating a computation marks it to be rerun at\n[flush time](#deps_flush), at\nwhich point the computation becomes valid again.  It is rare to\ninvalidate a computation manually, because reactive data sources\ninvalidate their calling computations when they change.  Reactive data\nsources in turn perform this invalidation using one or more\n[`Deps.Dependency`](#deps_dependency) objects.\n\nInvalidating a computation immediately calls all `onInvalidate`\ncallbacks registered on it.  Invalidating a computation that is\ncurrently invalidated or is stopped has no effect.  A computation can\ninvalidate itself, but if it continues to do so indefinitely, the\nresult will be an infinite loop.\n\n",["#",[[0,"with"],[0,"computation_oninvalidate"]],[[">","api_box"]]],"\n\n`onInvalidate` registers a one-time callback that either fires\nimmediately or as soon as the computation is next invalidated or\nstopped.  It is used by reactive data sources to clean up resources or\nbreak dependencies when a computation is rerun or stopped.\n\nTo get a callback after a computation has been recomputed, you can\ncall [`Deps.afterFlush`](#deps_afterflush) from `onInvalidate`.\n\n",["#",[[0,"with"],[0,"computation_stopped"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"computation_invalidated"]],[[">","api_box"]]],"\n\nThis property is initially false.  It is set to true by `stop()` and\n`invalidate()`.  It is reset to false when the computation is\nrecomputed at flush time.\n\n",["#",[[0,"with"],[0,"computation_firstrun"]],[[">","api_box"]]],"\n\nThis property is a convenience to support the common pattern where a\ncomputation has logic specific to the first run.\n\n<h2 id=\"deps_dependency\"><span>Deps.Dependency</span></h2>\n\nA Dependency represents an atomic unit of reactive data that a\ncomputation might depend on.  Reactive data sources such as Session or\nMinimongo internally create different Dependency objects for different\npieces of data, each of which may be depended on by multiple\ncomputations.  When the data changes, the computations are\ninvalidated.\n\nDependencies don't store data, they just track the set of computations to\ninvalidate if something changes.  Typically, a data value will be\naccompanied by a Dependency object that tracks the computations that depend\non it, as in this example:\n\n    var weather = \"sunny\";\n    var weatherDep = new Deps.Dependency;\n\n    var getWeather = function () {\n      weatherDep.depend()\n      return weather;\n    };\n\n    var setWeather = function (w) {\n      weather = w;\n      // (could add logic here to only call changed()\n      // if the new value is different from the old)\n      weatherDep.changed();\n    };\n\nThis example implements a weather data source with a simple getter and\nsetter.  The getter records that the current computation depends on\nthe `weatherDep` dependency using `depend()`, while the setter\nsignals the dependency to invalidate all dependent computations by\ncalling `changed()`.\n\nThe reason Dependencies do not store data themselves is that it can be\nuseful to associate multiple Dependencies with the same piece of data.\nFor example, one Dependency might represent the result of a database\nquery, while another might represent just the number of documents in\nthe result.  A Dependency could represent whether the weather is sunny\nor not, or whether the temperature is above freezing.\n[`Session.equals`](#session_equals) is implemented this way for\nefficiency.  When you call `Session.equals(\"weather\", \"sunny\")`, the\ncurrent computation is made to depend on an internal Dependency that\ndoes not change if the weather goes from, say, \"rainy\" to \"cloudy\".\n\nConceptually, the only two things a Dependency can do are gain a\ndependent and change.\n\nA Dependency's dependent computations are always valid (they have\n`invalidated === false`).  If a dependent is invalidated at any time,\neither by the Dependency itself or some other way, it is immediately\nremoved.\n\n",["#",[[0,"with"],[0,"dependency_changed"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"dependency_depend"]],[[">","api_box"]]],"\n\n`dep.depend()` is used in reactive data source implementations to record\nthe fact that `dep` is being accessed from the current computation.\n\n",["#",[[0,"with"],[0,"dependency_hasdependents"]],[[">","api_box"]]],"\n\nFor reactive data sources that create many internal Dependencies,\nthis function is useful to determine whether a particular Dependency is\nstill tracking any dependency relationships or if it can be cleaned up\nto save memory.\n\n<h2 id=\"ejson\"><span>EJSON</span></h2>\n\nEJSON is an extension of JSON to support more types. It supports all JSON-safe\ntypes, as well as:\n\n - **Date** (JavaScript `Date`)\n - **Binary** (JavaScript `Uint8Array` or the\n   result of [`EJSON.newBinary`](#ejson_new_binary))\n - **User-defined types** (see [`EJSON.addType`](#ejson_add_type).  For example,\n [`Meteor.Collection.ObjectID`](#collection_object_id) is implemented this way.)\n\nAll EJSON serializations are also valid JSON.  For example an object with a date\nand a binary buffer would be serialized in EJSON as:\n\n    {\n      \"d\": {\"$date\": 1358205756553},\n      \"b\": {\"$binary\": \"c3VyZS4=\"}\n    }\n\nMeteor supports all built-in EJSON data types in publishers, method arguments\nand results, Mongo databases, and [`Session`](#session) variables.\n\n",["#",[[0,"with"],[0,"ejsonParse"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"ejsonStringify"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"ejsonFromJSONValue"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"ejsonToJSONValue"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"ejsonEquals"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"ejsonClone"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"ejsonNewBinary"]],[[">","api_box"]]],"\n\nBuffers of binary data are represented by `Uint8Array` instances on JavaScript\nplatforms that support them.  On implementations of JavaScript that do not\nsupport `Uint8Array`, binary data buffers are represented by standard arrays\ncontaining numbers ranging from 0 to 255, and the `$Uint8ArrayPolyfill` key\nset to `true`.\n\n",["#",[[0,"with"],[0,"ejsonIsBinary"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"ejsonAddType"]],[[">","api_box"]]],"\n\nWhen you add a type to EJSON, Meteor will be able to use that type in:\n\n - publishing objects of your type if you pass them to publish handlers.\n - allowing your type in the return values or arguments to\n   [methods](#methods_header).\n - storing your type client-side in Minimongo.\n - allowing your type in [`Session`](#session) variables.\n\n",["#",[[0,"note"]],["\n\n  MongoDB cannot store most user-defined types natively on the server.  Your\n  type will work in Minimongo, and you can send it to the client using a custom\n  publisher, but MongoDB can only store the types defined in\n  [BSON](http://bsonspec.org/).\n\n"]],"\n\nInstances of your type should implement the following interface:\n\n",["#",[[0,"with"],[0,"ejsonTypeClone"]],[[">","api_box"]]],"\n\n",["#",[[0,"with"],[0,"ejsonTypeEquals"]],[[">","api_box"]]],"\n\nThe `equals` method should define an [equivalence\nrelation](http://en.wikipedia.org/wiki/Equivalence_relation).  It should have\nthe following properties:\n\n - *Reflexivity* - for any instance `a`: `a.equals(a)` must be true.\n - *Symmetry* - for any two instances `a` and `b`: `a.equals(b)` if and only if `b.equals(a)`.\n - *Transitivity* - for any three instances `a`, `b`, and `c`: `a.equals(b)` and `b.equals(c)` implies `a.equals(c)`.\n\n",["#",[[0,"with"],[0,"ejsonTypeName"]],[[">","api_box"]]],"\n",["#",[[0,"with"],[0,"ejsonTypeToJSONValue"]],[[">","api_box"]]],"\n\nFor example, the `toJSONValue` method for\n[`Meteor.Collection.ObjectID`](#collection_object_id) could be:\n\n    function () {\n      return this.toHexString();\n    };\n\n<h2 id=\"http\"><span>HTTP</span></h2>\n\n`HTTP` provides an HTTP request API on the client and server.  To use\nthese functions, add the HTTP package to your project with `$ meteor add\nhttp`.\n\n",["#",[[0,"with"],[0,"httpcall"]],[[">","api_box"]]],"\n\nThis function initiates an HTTP request to a remote server. It returns\na result object with the contents of the HTTP response.  The result\nobject is detailed below.\n\nOn the server, this function can be run either synchronously or\nasynchronously.  If the callback is omitted, it runs synchronously,\nand the results are returned once the request completes. This is\nuseful when making server-to-server HTTP API calls from within Meteor\nmethods, as the method can succeed or fail based on the results of the\nsynchronous HTTP call.  In this case, consider using\n[`this.unblock()`](#method_unblock) to allow other methods to run in\nthe mean time.  On the client, this function must be used\nasynchronously by passing a callback.\n\nBoth HTTP and HTTPS protocols are supported.  The `url` argument must be\nan absolute URL including protocol and host name on the server, but may be\nrelative to the current host on the client.  The `query` option\nreplaces the query string of `url`.  Parameters specified in `params`\nthat are put in the URL are appended to any query string.\nFor example, with a `url` of `\"/path?query\"` and\n`params` of `{foo:\"bar\"}`, the final URL will be `\"/path?query&foo=bar\"`.\n\nThe `params` are put in the URL or the request body, depending on the\ntype of request.  In the case of request with no bodies, like GET and\nHEAD, the parameters will always go in the URL.  For a POST or other\ntype of request, the parameters will be encoded into the body with a\nstandard `x-www-form-urlencoded` content type, unless the `content`\nor `data` option is used to specify a body, in which case the\nparameters will be appended to the URL instead.\n\nThe callback receives two arguments, `error` and `result`.  The\n`error` argument will contain an Error if the request fails in any\nway, including a network error, time-out, or an HTTP status code in\nthe 400 or 500 range.  In case of a 4xx/5xx HTTP status code, the\n`response` property on `error` matches the contents of the result\nobject.  When run in synchronous mode, either `result` is returned\nfrom the function, or `error` is thrown.\n\nContents of the result object:\n\n<dl class=\"objdesc\">\n\n<dt><span class=\"name\">statusCode</span>\n  <span class=\"type\">Number</span></dt>\n<dd>Numeric HTTP result status code, or <code>null</code> on error.</dd>\n\n<dt><span class=\"name\">content</span>\n  <span class=\"type\">String</span></dt>\n<dd>The body of the HTTP response as a string.</dd>\n\n<dt><span class=\"name\">data</span>\n  <span class=\"type\">Object or <code>null</code></span></dt>\n<dd>If the response headers indicate JSON content, this contains the body of the document parsed as a JSON object.</dd>\n\n<dt><span class=\"name\">headers</span>\n  <span class=\"type\">Object</span></dt>\n<dd>A dictionary of HTTP headers from the response.</dd>\n\n</dl>\n\nExample server method:\n\n    Meteor.methods({checkTwitter: function (userId) {\n      check(userId, String);\n      this.unblock();\n      var result = HTTP.call(\"GET\", \"http://api.twitter.com/xyz\",\n                             {params: {user: userId}});\n      if (result.statusCode === 200)\n         return true\n      return false;\n    }});\n\nExample asynchronous HTTP call:\n\n    HTTP.call(\"POST\", \"http://api.twitter.com/xyz\",\n              {data: {some: \"json\", stuff: 1}},\n              function (error, result) {\n                if (result.statusCode === 200) {\n                  Session.set(\"twizzled\", true);\n                }\n              });\n\n\n",["#",[[0,"with"],[0,"http_get"]],[[">","api_box"]]],"\n",["#",[[0,"with"],[0,"http_post"]],[[">","api_box"]]],"\n",["#",[[0,"with"],[0,"http_put"]],[[">","api_box"]]],"\n",["#",[[0,"with"],[0,"http_del"]],[[">","api_box"]]],"\n\n\n<h2 id=\"email\"><span>Email</span></h2>\n\nThe `email` package allows sending email from a Meteor app. To use it, add the\npackage to your project with `$ meteor add email`.\n\nThe server reads from the `MAIL_URL` environment variable to determine how to\nsend mail. Currently, Meteor supports sending mail over SMTP; the `MAIL_URL`\nenvironment variable should be of the form\n`smtp://USERNAME:PASSWORD@HOST:PORT/`. For apps deployed with `meteor deploy`,\n`MAIL_URL` defaults to an account (provided by\n[Mailgun](http://www.mailgun.com/)) which allows apps to send up to 200 emails\nper day; you may override this default by assigning to `process.env.MAIL_URL`\nbefore your first call to `Email.send`.\n\nIf `MAIL_URL` is not set (eg, when running your application locally),\n`Email.send` outputs the message to standard output instead.\n\n",["#",[[0,"with"],[0,"email_send"]],[[">","api_box"]]],"\n\nYou must provide the `from` option and at least one of `to`, `cc`, and `bcc`;\nall other options are optional.\n\n`Email.send` only works on the server. Here is an example of how a\nclient could use a server method call to send an email. (In an actual\napplication, you'd need to be careful to limit the emails that a\nclient could send, to prevent your server from being used as a relay\nby spammers.)\n\n    // In your server code: define a method that the client can call\n    Meteor.methods({\n      sendEmail: function (to, from, subject, text) {\n        check([to, from, subject, text], [String]);\n\n        // Let other method calls from the same client start running,\n        // without waiting for the email sending to complete.\n        this.unblock();\n\n        Email.send({\n          to: to,\n          from: from,\n          subject: subject,\n          text: text\n        });\n      }\n    });\n\n    // In your client code: asynchronously send an email\n    Meteor.call('sendEmail',\n                'alice@example.com',\n                'bob@example.com',\n                'Hello from Meteor!',\n                'This is a test of Email.send.');\n\n"]],"\n\n<h2 id=\"assets\"><span>Assets</span></h2>\n\n",["#",[[0,"better_markdown"]],["\n`Assets` allows server code in a Meteor application to access static server\nassets, which are located in the `private` subdirectory of an application's\ntree.\n\n",["#",[[0,"with"],[0,"assets_getText"]],[[">","api_box"]]],"\n",["#",[[0,"with"],[0,"assets_getBinary"]],[[">","api_box"]]],"\n\nStatic server assets are included by placing them in the application's `private`\nsubdirectory. For example, if an application's `private` subdirectory includes a\ndirectory called `nested` with a file called `data.txt` inside it, then server\ncode can read `data.txt` by running:\n\n    var data = Assets.getText('nested/data.txt');\n"]]]));
Template.__define__("api_box",Package.handlebars.Handlebars.json_ast_to_func(["<div class=\"api ",["{",[[0,"bare"]]],"\">\n<h3 id=\"",["{",[[0,"id"]]],"\">\n  <a class=\"name selflink\" href=\"#",["{",[[0,"id"]]],"\">",["!",[[0,"name"]]],"</a>\n",["#",[[0,"if"],[0,"locus"]],["\n  <span class=\"locus\">",["{",[[0,"locus"]]],"</span>\n"]],"\n</h3>\n\n<div class=\"desc\">\n",["#",[[0,"each"],[0,"descr"]],[["#",[[0,"better_markdown"]],[["!",[[0]]]]]]],"\n</div>\n\n",["#",[[0,"if"],[0,"args"]],["\n<h4>Arguments</h4>\n",["#",[[0,"with"],[0,"args"]],[[">","api_box_args"]]],"\n"]],"\n\n",["#",[[0,"if"],[0,"options"]],["\n<h4>Options</h4>\n",["#",[[0,"with"],[0,"options"]],[[">","api_box_args"]]],"\n"]],"\n\n",["#",[[0,"if"],[0,"body"]],["\n",["#",[[0,"better_markdown"]],[["!",[[0,"body"]]]]],"\n"]],"\n\n</div>"]));
Template.__define__("api_box_args",Package.handlebars.Handlebars.json_ast_to_func(["<dl class=\"args\">\n",["#",[[0,"each"],[0]],["\n<dt><span class=\"name\">",["!",[[0,"name"]]],"</span>\n  <span class=\"type\">\n    ",["#",[[0,"if"],[0,"type_link"]],["\n      <a href=\"#",["{",[[0,"type_link"]]],"\">",["!",[[0,"type"]]],"</a>\n    "],["\n      ",["!",[[0,"type"]]],"\n    "]],"\n  </span></dt>\n<dd>",["#",[[0,"better_markdown"]],[["!",[[0,"descr"]]]]],"</dd>\n"]],"\n</dl>"]));
Template.__define__("api_section_helper",Package.handlebars.Handlebars.json_ast_to_func(["<h2 id=\"",["{",[[0,"id"]]],"\"><a href=\"#",["{",[[0,"id"]]],"\" class=\"selflink\"><span>",["{",[[0,"name"]]],"</span></a></h2>"]));

})();
