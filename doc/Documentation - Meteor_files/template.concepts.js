(function(){Template.__define__("concepts",Package.handlebars.Handlebars.json_ast_to_func(["<h1 id=\"concepts\">Concepts</h1>\n\nWe've written our fair share of single-page JavaScript applications by hand.\nWriting an entire application in one language (JavaScript) with one\ndata format (JSON) is a real joy.  Meteor is everything we wanted\nwhen writing those apps.\n\n",[">","whatismeteor"],"\n",[">","structure"],"\n",[">","data"],"\n",[">","reactivity"],"\n",[">","livehtml"],"\n",[">","templates"],"\n",[">","packages_concept"],"\n",[">","namespacing"],"\n",[">","deploying"],"\n",[">","packages_writing"]]));
Template.__define__("whatismeteor",Package.handlebars.Handlebars.json_ast_to_func([["#",[[0,"better_markdown"]],["\n\n<h2 id=\"whatismeteor\">What is Meteor?</h2>\n\nMeteor is two things:\n\n* A _library of packages_: pre-written, self-contained modules that\nyou might need in your app.<br>\nThere are about a dozen core Meteor\npackages that most any app will use (for example `webapp`, which\nhandles incoming HTTP connections, and `templating`, which lets you\nmake HTML templates that automatically update live as data changes).\nThen there are optional packages like `email`, which lets your app\nsend emails, or the Meteor Accounts series (`account-password`,\n`accounts-facebook`, `accounts-ui`, and others) which provide a\nfull-featured user account system that you can drop right into your\napp. And beyond these \"official\" packages, there are hundreds of\ncommunity-written packages in [Atmosphere](https://atmosphere.meteor.com/),\none of which might do just what you need.\n\n* A _command-line tool_ called `meteor`.<br>\n`meteor` is a build tool analogous to `make`, `rake`, or the non-visual parts of\nVisual Studio. It gathers up all of the source files and assets in your\napplication, carries out any necessary build steps (such as compiling\n[CoffeeScript](http://coffeescript.org), minifying CSS, building\n[npm](https://npmjs.org/) modules, or generating source maps), fetches the\npackages used by your app, and outputs a standalone, ready-to-run application\nbundle. In development mode it can do all of this interactively, so that\nwhenever you change a file you immediately see the changes in your browser. It's\nsuper easy to use out of the box, but it's also extensible: you can add support\nfor new languages and compilers by adding build plugin packages to your app.\n\nThe key idea in the Meteor package system is that _everything should\nwork identically in the browser and on the server_ (wherever it makes\nsense, of course: browsers can't send email and servers can't capture\nmouse events). Our whole ecosystem has been built from the ground up\nto support this.\n\n",["#",[[0,"note"]],["\n`meteor` cannot yet fetch packages from Atmosphere. If you are using\nAtmosphere packages you should take a look at\n[Meteorite](http://oortcloud.github.io/meteorite/), a tool that will\nhelp you download and manage your Atmosphere packages.\n\nIn Meteor 1.0, the `meteor` build tool will have full support for\nAtmosphere.\n"]],"\n\n"]]]));
Template.__define__("structure",Package.handlebars.Handlebars.json_ast_to_func([["#",[[0,"better_markdown"]],["\n\n<h2 id=\"structuringyourapp\">Structuring your application</h2>\n\nA Meteor application is a mix of JavaScript that runs inside a client web\nbrowser, JavaScript that runs on the Meteor server inside a\n[Node.js](http://nodejs.org/) container, and all the supporting HTML fragments,\nCSS rules, and static assets.  Meteor automates the packaging and transmission\nof these different components.  And, it is quite flexible about how you choose\nto structure those components in your file tree.\n\nThe only server assets are JavaScript and files in the `private` subdirectory.\nMeteor gathers all your JavaScript\nfiles, excluding anything under the `client`, `public`, and `private`\nsubdirectories, and loads them into a Node.js\nserver instance inside a fiber.  In Meteor, your server code runs in\na single thread per request, not in the asynchronous callback style\ntypical of Node.  We find the linear execution model a better fit for\nthe typical server code in a Meteor application.\n\nMeteor gathers any files under the `private` subdirectory and makes the contents\nof these files available to server code via the [`Assets`](#assets) API. The\n`private` subdirectory is the place for any files that should be accessible to\nserver code but not served to the client, like private data files.\n\nThere are more assets to consider on the client side.  Meteor\ngathers all JavaScript files in your tree, with the exception of\nthe `server`, `public`, and `private` subdirectories, for the\nclient.  It minifies this bundle and serves it to each new client.\nYou're free to use a single JavaScript file for your entire application, or\ncreate a nested tree of separate files, or anything in between.\n\nSome JavaScript libraries only work when placed in the\n`client/compatibility` subdirectory.  Files in this directory are\nexecuted without being wrapped in a new variable scope.  This means\nthat each top-level `var` defines a global variable. In addition,\nthese files are executed before other client-side JavaScript files.\n\nFiles outside the `client`, `server` and `tests` subdirectories are loaded on\nboth the client and the server!  That's the place for model definitions and\nother functions.  Meteor provides the variables [`isClient`](#meteor_isclient) and\n[`isServer`](#meteor_isserver) so that your code can alter its behavior depending\non whether it's running on the client or the server. (Files in directories named\n`tests` are not loaded anywhere.)\n\nAny sensitive code that you don't want served to the client, such as code\ncontaining passwords or authentication mechanisms, should be\nkept in the `server` directory.\n\nCSS files are gathered together as well: the client will get a bundle with all\nthe CSS in your tree (excluding the `server`,\n`public`, and `private` subdirectories).\n\nIn development mode, JavaScript and CSS files are sent individually to make\ndebugging easier.\n\nHTML files in a Meteor application are treated quite a bit differently\nfrom a server-side framework.  Meteor scans all the HTML files in your\ndirectory for three top-level elements: `<head>`, `<body>`, and\n`<template>`.  The head and body sections are separately concatenated\ninto a single head and body, which are transmitted to the client on\ninitial page load.\n\nTemplate sections, on the other hand, are converted into JavaScript\nfunctions, available under the `Template` namespace.  It's\na really convenient way to ship HTML templates to the client.\nSee the [templates](#templates) section for more.\n\nLastly, the Meteor server will serve any files under the `public`\ndirectory, just like in a Rails or Django project.  This is the place\nfor images, `favicon.ico`, `robots.txt`, and anything else.\n\nIt is best to write your application in such a way that it is\ninsensitive to the order in which files are loaded, for example by\nusing [Meteor.startup](#meteor_startup), or by moving load order\nsensitive code into [packages](#usingpackages), which can explicitly control both\nthe load order of their contents and their load order with respect to\nother packages. However sometimes load order dependencies in your\napplication are unavoidable. The JavaScript and CSS files in an\napplication are loaded according to these rules:\n\n* Files in the `lib` directory at the root of your application are\n  loaded first.\n\n* Files that match `main.*` are loaded after everything else.\n\n* Files in subdirectories are loaded before files in parent\n  directories, so that files in the deepest subdirectory are loaded\n  first (after `lib`), and files in the root directory are loaded last\n  (other than `main.*`).\n\n* Within a directory, files are loaded in alphabetical order by\n  filename.\n\nThese rules stack, so that within `lib`, for example, files are still\nloaded in alphabetical order; and if there are multiple files named\n`main.js`, the ones in subdirectories are loaded earlier.\n\n"]]]));
Template.__define__("data",Package.handlebars.Handlebars.json_ast_to_func([["#",[[0,"better_markdown"]],["\n\n<h2 id=\"dataandsecurity\">Data and security</h2>\n\nMeteor makes writing distributed client code as simple as talking to a\nlocal database.  It's a clean, simple, and secure approach that obviates\nthe need to implement individual RPC endpoints, manually cache data on\nthe client to avoid slow roundtrips to the server, and carefully\norchestrate invalidation messages to every client as data changes.\n\nIn Meteor, the client and server share the same database API.  The same\nexact application code &mdash; like validators and computed properties &mdash; can\noften run in both places.  But while code running on the server has\ndirect access to the database, code running on the client does *not*.\nThis distinction is the basis for Meteor's data security model.\n\n",["#",[[0,"note"]],["\nBy default, a new Meteor app includes the `autopublish` and `insecure`\npackages, which together mimic the effect of each client having full\nread/write access to the server's database.  These are useful\nprototyping tools, but typically not appropriate for production\napplications.  When you're ready, just remove the packages.\n"]],"\n\nEvery Meteor client includes an in-memory database cache.  To manage the\nclient cache, the server *publishes* sets of JSON documents, and the\nclient *subscribes* to those sets.  As documents in a set change, the\nserver patches each client's cache.\n\nToday most Meteor apps use MongoDB as their database because it is the\nbest supported, though support for other databases is coming in the\nfuture. The\n[`Meteor.Collection`](http://docs.meteor.com/#meteor_collection) class\nis used to declare Mongo collections and to manipulate them. Thanks to\n`minimongo`, Meteor's client-side Mongo emulator, `Meteor.Collection`\ncan be used from both client and server code.\n\n    // declare collections\n    // this code should be included in both the client and the server\n    Rooms = new Meteor.Collection(\"rooms\");\n    Messages = new Meteor.Collection(\"messages\");\n    Parties = new Meteor.Collection(\"parties\");\n\n    // server: populate collections with some initial documents\n    Rooms.insert({name: \"Conference Room A\"});\n    var myRooms = Rooms.find({}).fetch();\n    Messages.insert({text: \"Hello world\", room: myRooms[0]._id});\n    Parties.insert({name: \"Super Bowl Party\"});\n\nEach document set is defined by a publish function on the server.  The\npublish function runs each time a new client subscribes to a document\nset.  The data in a document set can come from anywhere, but the common\ncase is to publish a database query.\n\n    // server: publish all room documents\n    Meteor.publish(\"all-rooms\", function () {\n      return Rooms.find(); // everything\n    });\n\n    // server: publish all messages for a given room\n    Meteor.publish(\"messages\", function (roomId) {\n      check(roomId, String);\n      return Messages.find({room: roomId});\n    });\n\n    // server: publish the set of parties the logged-in user can see.\n    Meteor.publish(\"parties\", function () {\n      return Parties.find({$or: [{\"public\": true},\n                                 {invited: this.userId},\n                                 {owner: this.userId}]});\n    });\n\nPublish functions can provide different results to each client.  In the\nlast example, a logged in user can only see `Party` documents that\nare public, that the user owns, or that the user has been invited to.\n\nOnce subscribed, the client uses its cache as a fast local database,\ndramatically simplifying client code.  Reads never require a costly\nround trip to the server.  And they're limited to the contents of the\ncache: a query for every document in a collection on a client will only\nreturn documents the server is publishing to that client.\n\n    // client: start a parties subscription\n    Meteor.subscribe(\"parties\");\n\n    // client: return array of Parties this client can read\n    return Parties.find().fetch(); // synchronous!\n\nSophisticated clients can turn subscriptions on and off to control how\nmuch data is kept in the cache and manage network traffic.  When a\nsubscription is turned off, all its documents are removed from the cache\nunless the same document is also provided by another active\nsubscription.\n\nWhen the client *changes* one or more documents, it sends a message to\nthe server requesting the change.  The server checks the proposed change\nagainst a set of allow/deny rules you write as JavaScript functions.\nThe server only accepts the change if all the rules pass.\n\n    // server: don't allow client to insert a party\n    Parties.allow({\n      insert: function (userId, party) {\n        return false;\n      }\n    });\n\n    // client: this will fail\n    var party = { ... };\n    Parties.insert(party);\n\nIf the server accepts the change, it applies the change to the database\nand automatically propagates the change to other clients subscribed to\nthe affected documents.  If not, the update fails, the server's database\nremains untouched, and no other client sees the update.\n\nMeteor has a cute trick, though.  When a client issues a write to the\nserver, it also updates its local cache immediately, without waiting for\nthe server's response.  This means the screen will redraw right away.\nIf the server accepted the update &mdash; what ought to happen most of the\ntime in a properly behaving client &mdash; then the client got a jump on the\nchange and didn't have to wait for the round trip to update its own\nscreen.  If the server rejects the change, Meteor patches up the\nclient's cache with the server's result.\n\nPutting it all together, these techniques accomplish latency\ncompensation.  Clients hold a fresh copy of the data they need, and\nnever need to wait for a roundtrip to the server. And when clients\nmodify data, those modifications can run locally without waiting for the\nconfirmation from the server, while still giving the server final say\nover the requested change.\n\n",["#",[[0,"note"]],["\nThe current release of Meteor supports MongoDB, the popular document\ndatabase, and the examples in this section use the\n        [MongoDB API](http://www.mongodb.org/display/DOCS/Manual).  Future\nreleases will include support for other databases.\n"]],"\n\n<h3 id=\"dataandsecurity-authentication\">Authentication and user accounts</h3>\n\nMeteor includes [Meteor Accounts](#accounts_api), a state-of-the-art\nauthentication system. It features secure password login using the\n[Secure Remote Password\nprotocol](http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol),\nand integration with external services including Facebook, GitHub,\nGoogle, Meetup, Twitter, and Weibo. Meteor Accounts defines a\n[`Meteor.users`](#meteor_users) collection where developers can store\napplication-specific user data.\n\nMeteor also includes pre-built forms for common tasks like login, signup,\npassword change, and password reset emails. You can add [Accounts\nUI](#accountsui) to your app with just one line of code. The `accounts-ui` package even provides a configuration wizard that walks you through the steps to\nset up the external login services you're using in your app.\n\n<h3 id=\"dataandsecurity-validation\">Input validation</h3>\n\nMeteor allows your methods and publish functions to take arguments of any\n[JSON](http://json.org/) type. (In fact, Meteor's wire protocol supports\n[EJSON](#ejson), an extension of JSON which also supports other common types\nlike dates and binary buffers.) JavaScript's dynamic typing means you don't need\nto declare precise types of every variable in your app, but it's usually helpful\nto ensure that the arguments that clients are passing to your methods and\npublish functions are of the type that you expect.\n\nMeteor provides a [lightweight library](#match) for checking that arguments and\nother values are the type you expect them to be. Simply start your functions\nwith statements like `check(username, String)` or\n`check(office, {building: String, room: Number})`. The `check` call will\nthrow an error if its argument is of an unexpected type.\n\nMeteor also provides an easy way to make sure that all of your methods\nand publish functions validate all of their arguments. Just run\n<code>meteor add [audit-argument-checks](#auditargumentchecks)</code> and any\nmethod or publish function which skips `check`ing any of its arguments will fail\nwith an exception.\n\n"]]]));
Template.__define__("reactivity",Package.handlebars.Handlebars.json_ast_to_func([["#",[[0,"better_markdown"]],["\n\n<h2 id=\"reactivity\">Reactivity</h2>\n\nMeteor embraces the concept of [reactive\nprogramming](http://en.wikipedia.org/wiki/Reactive_programming). This means that\nyou can write your code in a simple imperative style, and the result will be\nautomatically recalculated whenever data changes that your code depends on.\n\n    Deps.autorun(function () {\n      Meteor.subscribe(\"messages\", Session.get(\"currentRoomId\"));\n    });\n\nThis example (taken from a chat room client) sets up a data\nsubscription based on the session variable `currentRoomId`.\nIf the value of `Session.get(\"currentRoomId\")` changes for any reason, the\nfunction will be automatically re-run, setting up a new subscription that\nreplaces the old one.\n\nThis automatic recomputation is achieved by a cooperation between\n`Session` and `Deps.autorun`.  `Deps.autorun` performs an arbitrary \"reactive\ncomputation\" inside of which data dependencies are tracked, and it\nwill re-run its function argument as necessary.  Data providers like\n`Session`, on the other hand, make note of the computation they are\ncalled from and what data was requested, and they are prepared to send\nan invalidation signal to the computation when the data changes.\n\nThis simple pattern (reactive computation + reactive data source) has wide\napplicability.  Above, the programmer is saved from writing\nunsubscribe/resubscribe calls and making sure they are called at the\nright time.  In general, Meteor can eliminate whole classes of data\npropagation code which would otherwise clog up your application with\nerror-prone logic.\n\nThese Meteor functions run your code as a reactive computation:\n\n* [Templates](#templates)\n* [`Meteor.render`](#meteor_render) and [`Meteor.renderList`](#meteor_renderlist)\n* [`Deps.autorun`](#deps_autorun)\n\nAnd the reactive data sources that can trigger changes are:\n\n* [`Session`](#session) variables\n* Database queries on [Collections](#find)\n* [`Meteor.status`](#meteor_status)\n* The `ready()` method on a [subscription handle](#meteor_subscribe)\n* [`Meteor.user`](#meteor_user)\n* [`Meteor.userId`](#meteor_userid)\n* [`Meteor.loggingIn`](#meteor_loggingin)\n\nIn addition, the following functions which return an object with a\n`stop` method, if called from a reactive computation, are stopped when\nthe computation is rerun or stopped:\n\n* [`Deps.autorun`](#deps_autorun) (nested)\n* [`Meteor.subscribe`](#meteor_subscribe)\n* [`observe()`](#observe) and [`observeChanges()`](#observe_changes) on cursors\n\nMeteor's\n[implementation](https://github.com/meteor/meteor/blob/master/packages/deps/deps.js)\nis a package called [`Deps`](#deps) that is fairly short and straightforward.\nYou can use it yourself to implement new reactive data sources.\n\n"]]]));
Template.__define__("livehtml",Package.handlebars.Handlebars.json_ast_to_func([["#",[[0,"better_markdown"]],["\n\n<h2 id=\"livehtml\">Live HTML</h2>\n\nHTML templating is central to web applications. With Meteor's live\npage update technology, you can render your HTML _reactively_, meaning\nthat it will update automatically to track changes in the data used to\ngenerate it.\n\nThis optional feature works with any HTML templating library, or even\nwith HTML you generate manually from JavaScript. Here's an example:\n\n    var fragment = Meteor.render(\n      function () {\n        var name = Session.get(\"name\") || \"Anonymous\";\n        return \"<div>Hello, \" + name + \"</div>\";\n      });\n    document.body.appendChild(fragment);\n\n    Session.set(\"name\", \"Bob\"); // page updates automatically!\n\n[`Meteor.render`](#meteor_render) takes a rendering function, that is, a\nfunction that returns some HTML as a string. It returns an auto-updating\n`DocumentFragment`. When there is a change to data used by the rendering\nfunction, it is re-run. The DOM nodes in the `DocumentFragment` then\nupdate themselves in-place, no matter where they were inserted on the\npage. It's completely automatic. [`Meteor.render`](#meteor_render) uses\na [reactive computation](#reactivity) to discover what data is used by the\nrendering function.\n\nMost of the time, though, you won't call these functions directly\n&mdash; you'll just use your favorite templating package, such as\nHandlebars or Jade. The `render` and `renderList` functions are intended\nfor people that are implementing new templating systems.\n\nMeteor normally batches up any needed updates and executes them only\nwhen your code isn't running. That way, you can be sure that the DOM\nwon't change out from underneath you. Sometimes you want the opposite\nbehavior. For example, if you've just inserted a record in the\ndatabase, you might want to force the DOM to update so you can find\nthe new elements using a library like jQuery. In that case, call\n[`Deps.flush`](#deps_flush) to bring the DOM up to date\nimmediately.\n\nWhen live-updating DOM elements are taken off the screen, they are automatically\ncleaned up &mdash; their callbacks are torn down, any associated database\nqueries are stopped, and they stop updating. For this reason, you never have to\nworry about the [zombie\ntemplates](http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/)\nthat plague hand-written update logic. To protect your elements from cleanup,\njust make sure that they are on-screen before your code returns to the event loop,\nor before any call you make to [`Deps.flush`](#deps_flush).\n\nAnother thorny problem in hand-written applications is element\npreservation. Suppose the user is typing text into an `<input>`\nelement, and then the area of the page that includes that element is\nredrawn. The user could be in for a bumpy ride, as the focus, the\ncursor position, the partially entered text, and the accented\ncharacter input state will be lost when the `<input>` is recreated.\n\nThis is another problem that Meteor solves for you. You can specify\nelements to preserve when templates are re-rendered with the\n[`preserve`](#template_preserve) directive on the template. Meteor will\npreserve these elements even when their enclosing template is\nrerendered, but will still update their children and copy over any\nattribute changes.\n\n"]]]));
Template.__define__("templates",Package.handlebars.Handlebars.json_ast_to_func([["#",[[0,"better_markdown"]],["\n\n<h2 id=\"templates\">Templates</h2>\n\nMeteor makes it easy to use your favorite HTML templating language,\nsuch as Handlebars or Jade, along with Meteor's live page update\ntechnology. Just write your template as you normally would, and Meteor\nwill take care of making it update in realtime.\n\nTo use this feature, create a file in your project with the `.html`\nextension. In the file, make a `<template>` tag and give it a\n`name` attribute. Put the template contents inside the tag. Meteor\nwill precompile the template, ship it down to the client, and make it\navailable as a function on the global `Template` object.\n\n",["#",[[0,"note"]],["\nToday, the only templating system that has been packaged for Meteor is\nHandlebars. Let us know what templating systems you'd like to use with\nMeteor. Meanwhile, see the [Handlebars\ndocumentation](http://www.handlebarsjs.com/) and [Meteor Handlebars\nextensions](https://github.com/meteor/meteor/wiki/Handlebars).\n"]],"\n\nA template with a `name` of `hello` is rendered by calling the\nfunction `Template.hello`, passing any data for the template:\n\n    <!-- in myapp.html -->\n    <template name=\"hello\">\n      <div class=\"greeting\">Hello there, ",["{",[[0,"dstache"]]],"first}} ",["{",[[0,"dstache"]]],"last}}!</div>\n    </","template>\n\n    // in the JavaScript console\n    > Template.hello({first: \"Alyssa\", last: \"Hacker\"});\n     => \"<div class=\"greeting\">Hello there, Alyssa Hacker!</div>\"\n\nThis returns a string. To use the template along with the [`Live\nHTML`](#livehtml) system, and get DOM elements that update\nautomatically in place, use [`Meteor.render`](#meteor_render):\n\n    Meteor.render(function () {\n      return Template.hello({first: \"Alyssa\", last: \"Hacker\"});\n    })\n      => automatically updating DOM elements\n\nThe easiest way to get data into templates is by defining helper\nfunctions in JavaScript. Just add the helper functions directly on the\n`Template.[template name]` object. For example, in this template:\n\n    <template name=\"players\">\n      ",["{",[[0,"dstache"]]],"#each topScorers}}\n        <div>",["{",[[0,"dstache"]]],"name}}</div>\n      ",["{",[[0,"dstache"]]],"/each}}\n    </","template>\n\ninstead of passing in `topScorers` as data when we call the\ntemplate function, we could define a function on `Template.players`:\n\n    Template.players.topScorers = function () {\n      return Users.find({score: {$gt: 100}}, {sort: {score: -1}});\n    };\n\nIn this case, the data is coming from a database query. When the\ndatabase cursor is passed to `#each`, it will wire up all of the\nmachinery to efficiently add and move DOM nodes as new results enter\nthe query.\n\nHelpers can take arguments, and they receive the current template data\nin `this`:\n\n    // in a JavaScript file\n    Template.players.leagueIs = function (league) {\n      return this.league === league;\n    };\n\n    <!-- in a HTML file -->\n    <template name=\"players\">\n      ",["{",[[0,"dstache"]]],"#each topScorers}}\n        ",["{",[[0,"dstache"]]],"#if leagueIs \"junior\"}}\n          <div>Junior: ",["{",[[0,"dstache"]]],"name}}</div>\n        ",["{",[[0,"dstache"]]],"/if}}\n        ",["{",[[0,"dstache"]]],"#if leagueIs \"senior\"}}\n          <div>Senior: ",["{",[[0,"dstache"]]],"name}}</div>\n        ",["{",[[0,"dstache"]]],"/if}}\n      ",["{",[[0,"dstache"]]],"/each}}\n    </","template>\n\n",["#",[[0,"note"]],["\nHandlebars note: `",["{",[[0,"dstache"]]],"#if leagueIs \"junior\"}}` is\nallowed because of a Meteor extension that allows nesting a helper\nin a block helper. (Both `if` and `leagueIs` are\ntechnically helpers, and stock Handlebars would not invoke\n`leagueIs` here.)\n"]],"\n\nHelpers can also be used to pass in constant data.\n\n    // Works fine with ",["{",[[0,"dstache"]]],"#each sections}}\n    Template.report.sections = [\"Situation\", \"Complication\", \"Resolution\"];\n\nFinally, you can use an `events` declaration on a template function to set up a\ntable of event handlers. The format is documented at [Event\nMaps](#eventmaps). The `this` argument to the event handler will be\nthe data context of the element that triggered the event.\n\n    <!-- myapp.html -->\n    <template name=\"scores\">\n      ",["{",[[0,"dstache"]]],"#each player}}\n        ",["{",[[0,"dstache"]]],"> playerScore}}\n      ",["{",[[0,"dstache"]]],"/each}}\n    </","template>\n\n    <template name=\"playerScore\">\n      <div>",["{",[[0,"dstache"]]],"name}}: ",["{",[[0,"dstache"]]],"score}}\n        <span class=\"givePoints\">Give points</span>\n      </div>\n    </","template>\n\n    <!-- myapp.js -->\n    Template.playerScore.events({\n      'click .givePoints': function () {\n        Users.update(this._id, {$inc: {score: 2}});\n      }\n    });\n\nPutting it all together, here's an example of how you can inject\narbitrary data into your templates, and have them update automatically\nwhenever that data changes. See [Live HTML](#livehtml) for further\ndiscussion.\n\n    <!-- in myapp.html -->\n    <template name=\"forecast\">\n      <div>It'll be ",["{",[[0,"dstache"]]],"prediction}} tonight</div>\n    </","template>\n\n    <!-- in myapp.js -->\n    // JavaScript: reactive helper function\n    Template.forecast.prediction = function () {\n      return Session.get(\"weather\");\n    };\n\n    <!-- in the console -->\n    > Session.set(\"weather\", \"cloudy\");\n    > document.body.appendChild(Meteor.render(Template.forecast));\n    In DOM:  <div>It'll be cloudy tonight</div>\n\n    > Session.set(\"weather\", \"cool and dry\");\n    In DOM:  <div>It'll be cool and dry tonight</div>\n\n"]]]));
Template.__define__("packages_concept",Package.handlebars.Handlebars.json_ast_to_func([["#",[[0,"better_markdown"]],["\n\n  <h2 id=\"usingpackages\">Using packages</h2>\n\nAll of the functionality you've read about so far is implemented as\nstandard Meteor packages. This is possible thanks to Meteor's\nunusually powerful package and build system. The same packages work in\nthe browser and on the server, and packages can contain plugins that\nextend the build process, such as `coffeescript` ([CoffeeScript](http://coffeescript.org)\ncompilation) or `templating` (compiling HTML templates).\n\nYou can see a list of available packages\nwith [`meteor list`](#meteorlist), add packages to your project\nwith [`meteor add`](#meteoradd), and remove them\nwith [`meteor remove`](#meteorremove).\n\nBy default all apps include the `standard-app-packages` package. This\nautomatically pulls in the packages that make up the core Meteor\nstack. To keep things simple, these core packages are also hidden in\nthe output for `meteor list`, but you can read the\n[source code of `standard-app-packages`](https://github.com/meteor/meteor/blob/master/packages/standard-app-packages/package.js)\nto see what they are (as Meteor is pre-1.0, they may change from release to\nrelease). If you want to build your own custom stack, just remove\n`standard-app-packages` from your app and add back in whichever of the standard\npackages you want to keep.\n\nIn addition to the packages in the official Meteor release being used\nby your app, `meteor list` and `meteor add` also search the `packages`\ndirectory at the top of your app. If you've downloaded an unofficial\npackage from Atmosphere you should unpack it into that directory (the\nunofficial [Meteorite](http://oortcloud.github.io/meteorite/) tool\nstreamlines this process). You can also use the `packages` directory\nto break your app into subpackages for your convenience &mdash; if you\nare willing to brave the fact that the Meteor package format is not\ndocumented yet and will change significantly before Meteor 1.0. See\n[Writing Packages](#writingpackages).\n\n"]]]));
Template.__define__("namespacing",Package.handlebars.Handlebars.json_ast_to_func([["#",[[0,"better_markdown"]],["\n\n  <h2 id=\"namespacing\">Namespacing</h2>\n\nMeteor's namespacing support makes it easy to write large applications\nin JavaScript. Each package that you use in your app exists in its own\nseparate namespace, meaning that it sees only its own global variables\nand any variables provided by the packages that it specifically\nuses. Here's how it works.\n\nWhen you declare a top-level variable, you have a choice. You can make\nthe variable File Scope or Package Scope.\n\n    // File Scope. This variable will be visible only inside this\n    // one file. Other files in this app or package won't see it.\n    var alicePerson = {name: \"alice\"};\n\n    // Package Scope. This variable is visible to every file inside\n    // of this package or app. The difference is that 'var' is\n    // omitted.\n    bobPerson = {name: \"bob\"};\n\nNotice that this is just the normal JavaScript syntax for declaring a\nvariable that is local or global. Meteor scans your source code for\nglobal variable assignments and generates a wrapper that makes sure\nthat your globals don't escape their appropriate namespace.\n\nIn addition to File Scope and Package Scope, there are also\nExports. An export is a variable that a package makes available to you\nwhen you use it. For example, the `email` package exports the `Email`\nvariable. If your app uses the `email` package (and _only_ if it uses\nthe `email` package!) then your app can see `Email` and you can call\n`Email.send`. Most packages have only one export, but some packages\nmight have two or three (for example, a package that provides several\nclasses that work together).\n\nYou see only the exports of the packages that you use directly. If you\nuse package A, and package A uses package B, then you only see package\nA's exports. Package B's exports don't \"leak\" into your namespace just\nbecause you used package A. This keeps each namespace nice and\ntidy. Each app or package only sees their own globals plus the APIs of\nthe packages that they specifically asked for.\n\nWhen debugging your app, your browser's JavaScript console behaves as\nif it were attached to your app's namespace. You see your app's\nglobals and the exports of the packages that your app uses\ndirectly. You don't see the variables from inside those packages, and\nyou don't see the exports of your transitive dependencies (packages\nthat aren't used directly by your app, but that are used by packages\nthat are used by your app).\n\nIf you want to look inside packages from inside your in-browser\ndebugger, you've got two options:\n\n* Set a breakpoint inside package code. While stopped on that\n  breakpoint, the console will be in the package's namespace. You'll\n  see the package's package-scope variables, imports, and also any\n  file-scope variables for the file you're stopped in.\n\n* If a package `foo` is included in your app, regardless of whether\n  your app uses it directly, its exports are available in\n  `Package.foo`. For example, if the `email` package is loaded, then\n  you can access `Package.email.Email.send` even from namespaces that\n  don't use the `email` package directly.\n\nWhen declaring functions, keep in mind that `function x () {}` is just\nshorthard for `var x = function () {}` in JavaScript. Consider these\nexamples:\n\n    // This is the same as 'var x = function () ...'. So x() is\n    // file-scope and can be called only from within this one file.\n    function x () { ... }\n\n    // No 'var', so x() is package-scope and can be called from\n    // any file inside this app or package.\n    x = function () { ... }\n\n",["#",[[0,"note"]],["\nTechnically speaking, globals in an app (as opposed to in a package)\nare actually true globals. They can't be captured in a scope that is\nprivate to the app code, because that would mean that they wouldn't be\nvisible in the console during debugging! This means that app globals\nactually end up being visible in packages. That should never be a\nproblem for properly written package code (since the app globals will\nstill be properly shadowed by declarations in the packages). You\ncertainly shouldn't depend on this quirk, and in the future Meteor may\ncheck for it and throw an error if you do.\n"]],"\n\n"]]]));
Template.__define__("deploying",Package.handlebars.Handlebars.json_ast_to_func([["#",[[0,"better_markdown"]],["\n\n<h2 id=\"deploying\">Deploying</h2>\n\nMeteor is a full application server.  We include everything you need\nto deploy your application on the internet: you just provide the JavaScript,\nHTML, and CSS.\n\n<h3 class=\"nosection\">Running on Meteor's infrastructure</h3>\n\nThe easiest way to deploy your application is to use `meteor\ndeploy`.  We provide it because it's what, personally, we've always\nwanted: an easy way to take an app idea, flesh it out over a weekend,\nand put it out there for the world to use, with nothing getting in the\nway of creativity.\n\n    $ meteor deploy myapp.meteor.com\n\nYour application is now available at myapp.meteor.com.  If\nthis is the first time deploying to this hostname, Meteor creates a\nfresh empty database for your application.  If you want to deploy an\nupdate, Meteor will preserve the existing data and just refresh the\ncode.\n\nYou can also deploy to your own domain.  Just set up the hostname you\nwant to use as a CNAME to `origin.meteor.com`,\nthen deploy to that name.\n\n    $ meteor deploy www.myapp.com\n\nWe provide this as a free service so you can try Meteor.  It is also\nhelpful for quickly putting up internal betas, demos, and so on.\n\n<h3 class=\"nosection\">Running on your own infrastructure</h3>\n\nYou can also run your application on your own infrastructure, or any\nother hosting provider like Heroku.\n\nTo get started, run\n\n    $ meteor bundle myapp.tgz\n\nThis command will generate a fully-contained Node.js application in the form of\na tarball.  To run this application, you need to provide Node.js 0.8 and a\nMongoDB server.  (The current release of Meteor has been tested with Node\n0.8.24.) You can then run the application by invoking node, specifying the HTTP\nport for the application to listen on, and the MongoDB endpoint.  If you don't\nalready have a MongoDB server, we can recommend our friends at\n[MongoHQ](http://mongohq.com).\n\n    $ PORT=3000 MONGO_URL=mongodb://localhost:27017/myapp node bundle/main.js\n\nOther packages may require other environment variables (for example, the `email`\npackage requires a `MAIL_URL` environment variable).\n\n",["#",[[0,"warning"]],["\nFor now, bundles will only run on the platform that the bundle was\ncreated on.  To run on a different platform, you'll need to rebuild\nthe native packages included in the bundle.  To do that, make sure you\nhave `npm` available, and run the following:\n\n    $ cd bundle/programs/server/node_modules\n    $ rm -r fibers\n    $ npm install fibers@1.0.1\n"]],"\n\n"]]]));
Template.__define__("packages_writing",Package.handlebars.Handlebars.json_ast_to_func([["#",[[0,"better_markdown"]],["\n\n  <h2 id=\"writingpackages\">Writing packages</h2>\n\nThe Meteor package format isn't officially documented and will change\nbefore Meteor 1.0. But that hasn't stopped people like you from\ncreating hundreds of packages by reading the source code of existing\npackages and following the model. If you do decide to create your own\npackages, you will have to do some detective work, but here are some\nquick tips:\n\n* A package is simply a directory with a `package.js` file in it. Look in the\n  [`packages` directory of the Meteor source\n  tree](https://github.com/meteor/meteor/tree/master/packages/) for example\n  `package.js` files. The format and name of the `package.js` file will change\n  significantly before Meteor 1.0, but the functionality will be basically the\n  same even though the syntax is different, so it will be easy to port your\n  code.\n\n* Packages explicitly list all of their source files using `api.add_files`, and\n  the files are loaded exactly in the order specified. (This is different from\n  apps, where Meteor scans a directory tree to find the source files.)  Don't\n  forget to include any build plugin packages (such as `coffeescript` or, if\n  using HTML templates, `templating`) that you require.\n\n* Exporting a symbol from your package (see\n  [Namespacing](#namespacing)) is accomplished with an `api.export` call\n  from inside your `on_use` handler.\n\n* An esoteric point about exports: they are not lvalues. You can't set\n  an exported variable to a new value after exporting it. If you\n  export `a = {name: 'alice'}` then you can change `a.name` anytime\n  you want, but if after startup you set `a` to a whole new object\n  then the packages that import `a` won't see the change. Since your\n  exports are most always objects or functions, this is hardly ever an\n  issue.\n\n* Packages can use [npm modules](https://npmjs.org/). Use `Npm.depends` in your\n  `package.js` to list the npm modules that you need and the specific\n  versions that you want to use. Then use `Npm.require` inside your\n  package to pull in the modules when you need them. Meteor strives to\n  have 100% repeatable builds so that everyone on your team is always\n  running the same code, and that's why you must explicitly lock your\n  npm dependencies to specific versions. Behind the scenes, Meteor\n  will use `npm shrinkwrap` to also lock down the versions of the\n  transitive dependencies of all of the npm modules that you use.\n\n* Whenever your package changes, Meteor will rebuild it (compiling\n  non-JavaScript source files, fetching npm dependencies, constructing\n  namespace wrappers, and so on). The built package will be cached and\n  rebuilt only when a source file changes (tracked by SHA1) or when\n  other dependencies such as build plugins change. To force a rebuild\n  you can use the undocumented command `meteor rebuild-all`, but this\n  should never be necessary (if it is, please send a\n  [bug report](https://github.com/meteor/meteor/blob/devel/Contributing.md#filing-bug-reports)!).\n\n* Build plugins are created with `_transitional_registerBuildPlugin`,\n  an API that is very much in flux. See the `coffeescript` package for\n  an example. Build plugins are fully-fledged Meteor programs in their\n  own right and have their own namespace, package dependencies, source\n  files and npm requirements. The old `register_extension` API is\n  deprecated and should not be used as it will prevent your package\n  from being cached, slowing down builds.\n\n* It is possible to create weak dependencies between packages. If\n  package A has a weak dependency on package B, it means that\n  including A in an app does not force B to be included too &mdash;\n  but, if B _is_ included, say by the app developer or by another\n  package, then B will load before A. You can use this to make\n  packages that optionally integrate with or enhance other packages if\n  those packages are present. To create a weak dependency, pass\n  `{weak: true}` as the third argument to `api.use`. When you weakly\n  depend on a package you don't see its exports. You can detect if\n  the possibly-present weakly-depended-on package is there by seeing\n  if `Package.foo` exists, and get its exports from the same place.\n\n* It is also possible to create unordered dependencies by passing\n  `{unordered: true}`. An unordered dependency is the exact opposite\n  of a weak dependency. If A has an unordered dependency on B, then\n  including A forces B to be included as well, but doesn't require B\n  to load before A. This is occasionally useful for resolving circular\n  dependencies.\n\n* The build system also supports package implication. If package A\n  implies package B, then it means that when someone depends on\n  package A, it's as if they also depended on package B as well. In\n  particular, they get B's exports. This is done with `api.imply` and\n  can be used to create umbrella packages such as\n  `standard-app-packages` that are a shortcut for pulling in a set of\n  packages, or it can be helpful in factoring common code out of a set\n  of packages as with `accounts-base`.\n\n* The build system understands the idea of native code and has a\n  system of architecture names to ensure that packages that are\n  specific to one architecture aren't run on the wrong\n  architecture. For example, if you include an npm module that has a\n  native extension, your built Meteor package will be specific to your\n  machine architecture, but if not your built Meteor package will be\n  portable.\n\n"]]]));

})();
