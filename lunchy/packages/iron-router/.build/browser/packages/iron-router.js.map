{"version":3,"file":"\\packages\\iron-router.js","sources":["iron-router/lib\\utils.js","iron-router/lib\\route.js","iron-router/lib\\route_controller.js","iron-router/lib\\router.js","iron-router/lib\\client\\location.js","iron-router/lib\\client\\page_manager.js","iron-router/lib\\client\\router.js","iron-router/lib\\client\\default_layout.html","iron-router/lib\\client\\route_controller.js","iron-router/lib\\client\\helpers.js"],"names":[],"mappings":";;;;;;;;AAAA,G;AACA,sD;AACA,G;;AAEA,W;;AAEA,G;AACA,mD;AACA,G;;AAEA,4B;AACA,oC;AACA,kB;AACA,yC;AACA,kB;AACA,M;AACA,gB;AACA,E;;AAEA,G;AACA,8E;AACA,+E;AACA,e;AACA,E;AACA,Y;AACA,uD;AACA,+D;AACA,E;AACA,qC;AACA,G;;AAEA,6C;AACA,6B;AACA,W;AACA,U;;AAEA,gC;AACA,kC;AACA,iB;AACA,4C;AACA,0B;AACA,e;AACA,yB;AACA,K;AACA,U;AACA,sB;AACA,G;;AAEA,uD;AACA,a;AACA,E;;AAEA,4C;AACA,+B;AACA,6B;AACA,E;;AAEA,G;AACA,uE;AACA,4E;AACA,+E;AACA,yD;AACA,G;;AAEA,2C;AACA,kD;AACA,4E;AACA,G;AACA,mD;AACA,6E;;AAEA,2B;AACA,0C;AACA,+B;AACA,G;;AAEA,oB;AACA,6B;AACA,G;;AAEA,oC;AACA,+B;AACA,qC;AACA,e;AACA,E;;AAEA,gC;AACA,W;AACA,c;AACA,kD;AACA,iB;AACA,M;AACA,e;AACA,E;;AAEA,+B;AACA,0B;AACA,wB;AACA,M;AACA,+C;AACA,E;;AAEA,sE;AACA,6B;AACA,uB;AACA,Q;AACA,kC;AACA,8B;AACA,G;;AAEA,mC;AACA,oD;AACA,K;AACA,E;;AAEA,+C;AACA,iB;AACA,gB;AACA,qB;;AAEA,0B;AACA,gC;;AAEA,sD;AACA,yC;AACA,Q;AACA,+B;AACA,qE;AACA,wE;AACA,K;AACA,G;;AAEA,iC;;AAEA,kD;;AAEA,oD;AACA,qD;AACA,wD;AACA,I;;AAEA,mB;AACA,qC;AACA,G;;AAEA,sC;AACA,kE;;AAEA,8C;;AAEA,qB;AACA,E;;AAEA,G;AACA,6C;AACA,E;AACA,2E;AACA,2E;AACA,G;;AAEA,0C;AACA,iB;AACA,yB;AACA,E;;AAEA,wC;AACA,iB;AACA,iD;AACA,E;;AAEA,mC;AACA,yD;AACA,E;;AAEA,iC;AACA,oB;AACA,+C;AACA,kC;AACA,c;AACA,E;;AAEA,oC;AACA,iC;AACA,U;AACA,yC;AACA,kB;AACA,mD;AACA,iB;AACA,G;;AAEA,c;AACA,E;;;;;;;;;;;;;;;;;;;AC/LA,E;AACA,6E;AACA,+E;AACA,6E;AACA,kE;AACA,G;;AAEA,0C;AACA,W;;AAEA,6C;;AAEA,gC;AACA,iE;;AAEA,4B;AACA,mC;;AAEA,yC;AACA,sC;;AAEA,uB;AACA,2B;;AAEA,2E;AACA,gD;;AAEA,mB;AACA,yC;AACA,uC;;AAEA,8C;AACA,uC;AACA,M;AACA,2B;;AAEA,iB;AACA,E;;AAEA,mB;AACA,qB;;AAEA,K;AACA,uB;AACA,I;AACA,qB;AACA,iB;AACA,K;;AAEA,wB;AACA,mB;AACA,Y;AACA,+B;;AAEA,mB;;AAEA,8C;AACA,kC;AACA,Y;AACA,8B;AACA,gC;AACA,2C;AACA,iC;AACA,4B;AACA,iB;AACA,iD;AACA,kE;AACA,iE;AACA,gC;AACA,qB;AACA,uC;AACA,qB;AACA,uC;AACA,+B;AACA,wE;AACA,iC;AACA,W;AACA,S;AACA,oC;AACA,gC;AACA,M;AACA,2E;AACA,K;;AAEA,gB;AACA,I;;AAEA,K;AACA,0E;AACA,8C;AACA,I;AACA,yB;AACA,oB;AACA,gB;AACA,K;;AAEA,2B;AACA,2B;;AAEA,mB;AACA,2B;AACA,mB;AACA,wB;AACA,W;AACA,c;;AAEA,W;AACA,oG;;AAEA,mD;AACA,wB;AACA,wE;AACA,gB;AACA,4D;AACA,mC;AACA,Y;AACA,2B;AACA,K;;AAEA,2B;;AAEA,qC;AACA,oB;AACA,8C;;AAEA,qC;;AAEA,sB;AACA,6D;AACA,4C;AACA,kE;AACA,S;AACA,K;;AAEA,kB;AACA,I;;AAEA,kC;AACA,sC;;AAEA,oC;;AAEA,6C;AACA,sE;;AAEA,sC;AACA,wD;;AAEA,+B;AACA,wB;;AAEA,gB;AACA,I;;AAEA,K;AACA,0D;AACA,I;AACA,yB;AACA,uB;AACA,gB;AACA,K;AACA,yB;AACA,kD;AACA,I;;AAEA,yB;AACA,kD;AACA,I;;AAEA,uC;AACA,a;AACA,sB;AACA,c;AACA,yB;AACA,gC;AACA,Y;AACA,a;AACA,gC;;AAEA,4B;AACA,0B;AACA,0B;AACA,wB;;AAEA,iC;AACA,4E;AACA,Y;AACA,8B;AACA,iB;AACA,iD;AACA,mE;AACA,gC;AACA,gC;AACA,0D;;AAEA,8C;AACA,yB;AACA,yB;AACA,yC;AACA,qC;AACA,6H;AACA,qB;AACA,kI;AACA,a;;AAEA,qE;AACA,mF;AACA,iD;AACA,yB;AACA,uC;AACA,W;AACA,S;AACA,iB;AACA,gB;AACA,4B;AACA,+D;AACA,8B;AACA,6E;AACA,+B;AACA,uE;AACA,a;;AAEA,6D;AACA,oE;AACA,iD;AACA,yB;AACA,W;AACA,U;;AAEA,8B;AACA,4D;AACA,uE;AACA,qB;;AAEA,kC;AACA,qC;AACA,O;;AAEA,iB;AACA,gD;AACA,uB;AACA,iD;AACA,O;AACA,K;AACA,I;AACA,wC;AACA,I;;AAEA,oC;AACA,yC;AACA,I;;AAEA,mC;AACA,0C;AACA,wB;AACA,wC;AACA,uC;AACA,I;;AAEA,2C;AACA,oB;AACA,e;AACA,uB;AACA,kB;AACA,c;AACA,kB;;AAEA,0C;AACA,mC;AACA,gC;;AAEA,0C;AACA,0C;AACA,8C;AACA,wB;AACA,sD;AACA,O;;AAEA,wB;AACA,M;;AAEA,8E;AACA,2C;AACA,yC;AACA,2C;AACA,iD;AACA,8C;AACA,iB;AACA,kB;AACA,0B;AACA,+B;AACA,O;AACA,I;AACA,wD;AACA,0B;AACA,qD;AACA,0D;AACA,gD;AACA,wB;AACA,K;;AAEA,0E;AACA,0B;;AAEA,oB;AACA,yE;;AAEA,4B;AACA,kD;AACA,0B;AACA,O;AACA,K;;AAEA,8D;AACA,wC;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AC5TA,+E;AACA,yB;AACA,+E;;AAEA,G;AACA,oD;AACA,G;;AAEA,0C;AACA,kB;;AAEA,yC;;AAEA,kC;AACA,oD;AACA,I;;AAEA,+B;AACA,6B;AACA,2B;AACA,qC;AACA,yC;AACA,8C;AACA,kB;;AAEA,6C;AACA,iD;AACA,+C;AACA,iD;AACA,E;;AAEA,iC;AACA,mC;AACA,E;AACA,uC;AACA,+B;AACA,mC;;AAEA,iD;AACA,qB;;AAEA,yB;AACA,gF;AACA,M;AACA,uC;AACA,uD;AACA,M;;AAEA,iE;AACA,4C;AACA,sB;AACA,wE;;AAEA,sF;;AAEA,oD;AACA,uB;AACA,c;AACA,sB;AACA,K;AACA,I;;AAEA,oB;AACA,uC;AACA,I;;AAEA,uB;AACA,uC;AACA,I;;AAEA,oB;AACA,wB;AACA,G;AACA,E;;AAEA,+B;AACA,K;AACA,qC;AACA,I;AACA,yE;AACA,K;;AAEA,iC;AACA,iE;AACA,uB;AACA,M;AACA,Q;AACA,8E;AACA,mB;;AAEA,wB;AACA,uD;AACA,8C;;AAEA,mB;AACA,iD;AACA,kC;AACA,a;AACA,O;AACA,uC;AACA,6C;AACA,iC;AACA,S;AACA,O;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACzGA,+E;AACA,gB;AACA,+E;AACA,iC;AACA,kB;AACA,E;AACA,0B;;AAEA,K;AACA,oE;AACA,6B;AACA,I;AACA,gB;AACA,K;AACA,mB;AACA,E;AACA,yB;AACA,kF;AACA,E;;AAEA,8D;;AAEA,wB;AACA,0B;;AAEA,K;AACA,4E;AACA,wE;AACA,I;AACA,4B;AACA,yB;AACA,gB;AACA,K;AACA,E;AACA,iC;AACA,oB;AACA,I;AACA,sC;AACA,oC;AACA,I;AACA,4C;AACA,kD;AACA,+B;AACA,kE;AACA,mC;AACA,W;AACA,Q;AACA,kC;AACA,O;AACA,O;AACA,I;AACA,gB;AACA,I;;;AAGA,K;AACA,I;AACA,kE;AACA,iF;AACA,I;AACA,wE;AACA,uE;AACA,6C;AACA,yB;AACA,gB;AACA,I;AACA,K;AACA,E;AACA,0C;AACA,2B;;AAEA,qB;AACA,iD;AACA,uB;AACA,qD;AACA,M;AACA,iE;AACA,I;AACA,gB;AACA,I;AACA,E;AACA,iC;AACA,+C;AACA,I;;AAEA,mC;AACA,iD;AACA,I;AACA,E;AACA,kC;AACA,gD;AACA,I;AACA,E;AACA,mC;AACA,iD;AACA,I;AACA,E;AACA,K;AACA,I;AACA,uE;AACA,wD;AACA,I;AACA,wE;AACA,sE;AACA,0D;AACA,gB;AACA,I;AACA,K;AACA,I;AACA,kC;AACA,mB;AACA,I;AACA,oD;AACA,iC;AACA,M;AACA,4D;AACA,e;AACA,M;AACA,0D;AACA,e;AACA,M;AACA,4B;AACA,O;AACA,I;AACA,iB;AACA,I;AACA,E;;AAEA,K;AACA,+E;AACA,+C;AACA,I;AACA,a;AACA,8B;AACA,4B;AACA,S;AACA,I;AACA,0B;AACA,0B;AACA,iB;AACA,K;;AAEA,sB;AACA,kC;AACA,6D;AACA,kB;AACA,gB;AACA,I;;AAEA,K;AACA,+E;AACA,iE;AACA,I;AACA,+C;AACA,iE;AACA,oB;AACA,gB;AACA,K;;AAEA,mC;AACA,c;;AAEA,mE;AACA,I;AACA,iC;AACA,sB;AACA,Q;AACA,6C;;AAEA,8B;AACA,4B;AACA,iB;AACA,I;;AAEA,+C;AACA,uC;AACA,qB;AACA,4I;AACA,gD;AACA,I;;AAEA,8C;AACA,uC;AACA,sB;AACA,yI;AACA,+C;AACA,I;;AAEA,0C;AACA,mB;AACA,4B;AACA,a;AACA,kB;AACA,qD;AACA,c;;AAEA,sB;AACA,0B;;AAEA,mB;AACA,mD;AACA,O;;AAEA,6B;AACA,mC;AACA,iD;;AAEA,4D;AACA,iC;AACA,c;AACA,e;AACA,O;AACA,K;;AAEA,W;AACA,I;;AAEA,kC;AACA,2C;AACA,I;;AAEA,yC;AACA,mD;AACA,I;;AAEA,6C;AACA,sE;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACpOA,8B;AACA,mB;;AAEA,sB;AACA,2B;AACA,0D;AACA,qB;AACA,+C;;AAEA,kD;AACA,+D;AACA,kB;AACA,W;;AAEA,4C;AACA,W;AACA,E;AACA,qC;AACA,6B;AACA,W;AACA,E;AACA,6B;AACA,gB;AACA,W;AACA,E;AACA,iC;AACA,wC;AACA,W;AACA,E;AACA,kE;AACA,0C;AACA,qB;AACA,yB;AACA,C;;AAEA,yB;AACA,a;AACA,kB;AACA,C;;AAEA,kB;;AAEA,mC;AACA,kD;AACA,E;;AAEA,6C;AACA,qC;AACA,oC;AACA,E;;AAEA,gC;AACA,e;AACA,kB;AACA,E;;AAEA,iC;AACA,e;AACA,6D;AACA,E;;AAEA,4C;AACA,0B;;AAEA,kC;;AAEA,wB;AACA,e;AACA,Q;AACA,8B;AACA,sB;AACA,uC;AACA,G;;AAEA,uC;AACA,2B;AACA,sC;AACA,2B;AACA,gC;AACA,yD;AACA,M;AACA,sD;;AAEA,oC;AACA,kB;AACA,E;;AAEA,uD;AACA,gB;AACA,wB;AACA,yC;AACA,M;AACA,0B;AACA,E;;AAEA,0D;AACA,gB;AACA,2B;AACA,4C;AACA,M;AACA,0B;AACA,E;;AAEA,kC;AACA,qB;AACA,W;;AAEA,uC;AACA,8C;AACA,wB;AACA,E;AACA,wD;AACA,6B;AACA,8E;AACA,mE;AACA,6E;AACA,6D;AACA,2B;AACA,oF;AACA,E;;AAEA,iC;AACA,wC;AACA,6C;AACA,yB;AACA,E;;AAEA,qB;;;;;;;;;;;;;;;;;;;AC/HA,4B;AACA,yC;;AAEA,0D;AACA,6B;AACA,oB;AACA,8B;AACA,8B;AACA,qB;AACA,qB;AACA,M;AACA,wE;AACA,E;;AAEA,gD;AACA,6B;AACA,gB;AACA,+B;AACA,yE;AACA,E;;AAEA,oC;AACA,kC;AACA,8B;AACA,E;;AAEA,yB;AACA,yB;AACA,yC;AACA,a;;AAEA,wB;AACA,wB;AACA,I;;AAEA,oB;AACA,uB;AACA,uB;AACA,I;;AAEA,4B;AACA,uB;AACA,4C;AACA,G;AACA,E;;AAEA,2B;AACA,4C;AACA,gC;AACA,kC;AACA,kC;AACA,oB;AACA,E;;AAEA,yB;AACA,2B;;AAEA,gC;AACA,oB;AACA,sC;AACA,iC;AACA,kC;AACA,wC;;AAEA,+C;AACA,+B;AACA,0B;AACA,O;;AAEA,4B;AACA,I;;AAEA,wC;AACA,oB;;AAEA,0B;;AAEA,0E;AACA,wE;AACA,oE;;AAEA,gF;AACA,gF;AACA,6E;AACA,4E;AACA,+E;AACA,6E;AACA,oB;AACA,8B;AACA,mC;AACA,+C;AACA,iB;;AAEA,+B;AACA,+B;AACA,oI;AACA,c;AACA,6J;;AAEA,sC;AACA,+B;AACA,4C;AACA,gC;AACA,c;AACA,kC;AACA,S;AACA,S;AACA,O;;AAEA,6C;AACA,I;;AAEA,8B;AACA,0C;AACA,I;;AAEA,4B;AACA,wB;AACA,I;;AAEA,wB;AACA,2B;AACA,I;;AAEA,wB;AACA,oB;AACA,Y;AACA,wC;AACA,iB;;AAEA,iC;AACA,qB;;AAEA,yC;AACA,+C;AACA,O;AACA,M;AACA,I;;AAEA,mC;AACA,oB;;AAEA,4B;;AAEA,6E;AACA,6D;AACA,6B;;;AAGA,sC;AACA,2E;AACA,6D;AACA,uF;AACA,kB;AACA,S;;AAEA,gC;AACA,mC;AACA,oD;;AAEA,mC;AACA,O;AACA,I;;AAEA,6B;AACA,oB;;AAEA,0C;AACA,0D;AACA,iC;AACA,mC;AACA,oD;AACA,iC;AACA,O;;AAEA,gB;AACA,I;;AAEA,4C;AACA,oB;AACA,wD;;AAEA,sD;AACA,mB;AACA,O;;AAEA,2D;;AAEA,yC;AACA,2B;AACA,O;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AChMA,G;AACA,sB;AACA,E;AACA,sB;AACA,wB;AACA,sB;AACA,G;;AAEA,yC;AACA,K;AACA,iB;AACA,8B;AACA,2E;AACA,0E;AACA,W;AACA,K;;AAEA,mC;AACA,oB;;AAEA,8D;;AAEA,4B;;AAEA,iC;;AAEA,O;AACA,+E;AACA,wE;AACA,wB;AACA,M;AACA,mB;AACA,O;AACA,mC;;AAEA,O;AACA,gD;AACA,M;AACA,mB;AACA,O;AACA,8C;;AAEA,O;AACA,kE;AACA,kD;AACA,Q;AACA,oB;AACA,Q;AACA,kC;;AAEA,gC;AACA,8B;AACA,8C;AACA,4B;AACA,6C;AACA,uB;AACA,S;AACA,O;AACA,I;;AAEA,K;AACA,6E;AACA,2E;AACA,I;AACA,iD;AACA,iF;AACA,8B;AACA,gB;AACA,K;;AAEA,4B;AACA,wC;AACA,qC;AACA,U;AACA,mC;AACA,qC;AACA,K;AACA,I;;AAEA,gC;AACA,iC;AACA,I;;AAEA,wC;AACA,yC;AACA,I;;AAEA,4C;AACA,6C;AACA,I;;AAEA,4B;AACA,6B;AACA,I;;AAEA,wB;AACA,gC;AACA,I;;AAEA,kC;AACA,oB;AACA,sD;;AAEA,0D;;AAEA,+D;AACA,oC;AACA,4D;AACA,a;AACA,K;;AAEA,0C;AACA,iC;AACA,mC;AACA,Q;AACA,oC;AACA,sC;AACA,sC;AACA,Q;AACA,kC;AACA,2B;AACA,W;AACA,S;AACA,M;;AAEA,gC;AACA,iD;;AAEA,yC;;AAEA,iC;AACA,oC;AACA,8D;AACA,Y;AACA,2B;AACA,K;;AAEA,gD;AACA,2B;AACA,oC;AACA,K;AACA,I;;AAEA,K;AACA,+E;AACA,qE;AACA,I;AACA,c;AACA,I;AACA,8C;AACA,2D;AACA,I;AACA,oC;AACA,mC;AACA,4B;AACA,oC;AACA,gB;AACA,K;;AAEA,mD;AACA,6B;AACA,a;AACA,Y;AACA,kB;AACA,kB;AACA,2B;AACA,gC;AACA,gC;AACA,6C;AACA,+B;AACA,4B;AACA,W;AACA,Q;;AAEA,yC;AACA,6B;AACA,uB;AACA,+D;AACA,wE;AACA,yE;AACA,yE;AACA,e;AACA,yC;AACA,Y;AACA,2C;AACA,qE;AACA,yC;AACA,sD;AACA,iC;AACA,K;AACA,I;;AAEA,K;AACA,4E;AACA,+E;AACA,wE;AACA,I;AACA,uC;AACA,gB;AACA,K;;AAEA,uB;AACA,2B;AACA,qC;AACA,I;;AAEA,K;AACA,0E;AACA,8E;AACA,mB;AACA,I;AACA,gB;AACA,K;;AAEA,2B;AACA,oB;AACA,yC;AACA,2B;AACA,O;AACA,oC;AACA,I;;;AAGA,K;AACA,2E;AACA,yD;AACA,I;AACA,gB;AACA,K;;AAEA,sB;AACA,oB;;AAEA,+B;;AAEA,0B;AACA,I;AACA,+B;AACA,mB;AACA,oC;AACA,iE;AACA,O;AACA,I;;AAEA,K;AACA,yE;AACA,I;AACA,gB;AACA,K;;AAEA,qB;AACA,2B;;AAEA,kC;AACA,uC;AACA,I;;AAEA,K;AACA,sE;AACA,I;AACA,gB;AACA,K;AACA,yC;AACA,gB;AACA,2B;AACA,I;AACA,E;AACA,K;AACA,mE;AACA,0B;AACA,4E;AACA,yC;AACA,+E;AACA,I;AACA,gB;AACA,K;AACA,6C;AACA,6C;AACA,kB;AACA,6B;AACA,+C;AACA,kD;AACA,sD;AACA,Y;AACA,wE;AACA,K;AACA,G;AACA,G;;AAEA,G;AACA,uD;AACA,E;AACA,c;AACA,kB;AACA,G;;AAEA,0B;;AAEA,qB;AACA,2D;AACA,6E;AACA,E;AACA,oD;AACA,yD;AACA,iC;AACA,C;;;;;;;;;;;;;;;;;;ACjTA,+G;;;;;;;;;;;;;;;;;;;ACAA,+E;AACA,c;AACA,+E;AACA,wB;AACA,kC;AACA,e;AACA,E;;AAEA,sB;AACA,uB;AACA,2B;AACA,I;;AAEA,sB;AACA,oB;AACA,I;;AAEA,2B;AACA,oB;AACA,+B;AACA,+B;AACA,mB;AACA,O;AACA,I;;AAEA,sB;AACA,oB;;AAEA,W;AACA,a;;AAEA,iC;;AAEA,e;AACA,I;;AAEA,sB;AACA,gD;AACA,4B;AACA,O;AACA,G;AACA,E;;AAEA,+E;AACA,sB;AACA,+E;AACA,+B;AACA,kB;AACA,wE;AACA,uB;AACA,uB;AACA,G;AACA,E;;AAEA,kD;AACA,kB;AACA,4B;AACA,qD;AACA,iC;AACA,uC;AACA,wB;AACA,gB;AACA,G;AACA,E;;AAEA,iD;AACA,kB;;AAEA,sB;AACA,+B;AACA,wC;AACA,0B;AACA,kB;AACA,K;AACA,G;AACA,E;;AAEA,6C;AACA,qE;AACA,E;;AAEA,+E;AACA,qB;AACA,+E;AACA,qD;AACA,4B;AACA,iE;;AAEA,oB;;AAEA,oC;AACA,sD;AACA,M;;AAEA,wD;AACA,0D;AACA,kC;AACA,6E;AACA,sD;AACA,sD;AACA,I;AACA,M;AACA,2E;AACA,0E;AACA,2B;AACA,M;AACA,yB;AACA,yC;AACA,U;AACA,M;AACA,kC;AACA,6B;AACA,2D;AACA,S;AACA,U;AACA,M;AACA,yB;AACA,gE;AACA,O;AACA,O;AACA,oB;AACA,iD;AACA,0C;;AAEA,kC;AACA,I;;AAEA,sB;AACA,kC;AACA,I;;AAEA,K;AACA,gF;AACA,wB;AACA,I;AACA,gB;AACA,K;;AAEA,mC;AACA,gB;AACA,uE;AACA,I;;AAEA,K;AACA,6E;AACA,4E;AACA,yE;AACA,Y;AACA,I;AACA,a;AACA,I;AACA,uB;AACA,kE;AACA,4C;AACA,O;AACA,I;AACA,wB;AACA,gB;AACA,K;;AAEA,uB;;AAEA,uB;;AAEA,K;AACA,mC;AACA,I;AACA,4B;AACA,gB;AACA,K;;AAEA,iB;;AAEA,K;AACA,0E;AACA,0E;AACA,c;AACA,I;AACA,4B;AACA,gB;AACA,K;;AAEA,wB;;AAEA,K;AACA,qE;AACA,mE;AACA,I;AACA,4B;AACA,gB;AACA,K;;AAEA,yB;;AAEA,K;AACA,wE;AACA,e;AACA,I;AACA,4B;AACA,gB;AACA,K;;AAEA,W;;AAEA,wB;AACA,gD;AACA,I;;AAEA,4B;AACA,6C;AACA,I;;AAEA,e;;AAEA,I;AACA,yE;AACA,6E;AACA,8C;AACA,K;;AAEA,wD;AACA,oB;;AAEA,gC;AACA,wB;;AAEA,c;AACA,2B;AACA,4B;AACA,uB;AACA,sC;AACA,yB;AACA,W;AACA,S;AACA,Q;AACA,S;;AAEA,yD;AACA,qC;AACA,I;;AAEA,K;AACA,gF;AACA,+D;AACA,I;AACA,K;;AAEA,wC;AACA,W;AACA,iB;AACA,e;AACA,oB;;AAEA,2C;AACA,iC;AACA,gC;AACA,uC;AACA,O;AACA,M;;AAEA,gC;AACA,4D;AACA,yB;AACA,M;AACA,0B;AACA,Y;AACA,8B;AACA,sB;AACA,2D;AACA,2B;AACA,K;AACA,I;AACA,E;AACA,8B;AACA,4B;AACA,oB;AACA,I;AACA,uD;AACA,6B;AACA,O;AACA,I;;AAEA,kC;AACA,mD;AACA,I;;AAEA,oB;AACA,oB;AACA,oC;AACA,6E;;AAEA,wB;AACA,gG;;AAEA,yB;;AAEA,8B;;AAEA,oE;AACA,qE;AACA,+E;AACA,qE;AACA,2B;;AAEA,M;AACA,8E;AACA,+E;AACA,4E;AACA,O;AACA,qE;AACA,2E;AACA,Q;;AAEA,kC;;AAEA,wC;;AAEA,mC;AACA,6B;AACA,oC;AACA,kB;AACA,qC;AACA,O;;AAEA,uB;AACA,8B;AACA,a;AACA,K;;AAEA,mD;AACA,sB;;AAEA,kC;AACA,4B;AACA,+B;AACA,O;;AAEA,8B;AACA,4B;AACA,I;;AAEA,2B;AACA,+D;AACA,2E;AACA,kC;AACA,I;;AAEA,uB;AACA,kB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC9VA,iB;AACA,8E;;AAEA,gC;AACA,uB;AACA,oB;AACA,K;;AAEA,iC;AACA,6C;;AAEA,2C;AACA,mB;AACA,gB;AACA,O;AACA,K;;AAEA,6E;AACA,gC;AACA,uB;AACA,oB;AACA,K;;AAEA,iC;AACA,6C;;AAEA,0C;AACA,mB;AACA,gB;AACA,O;AACA,K;;AAEA,gE;AACA,sD;AACA,K;;AAEA,mE;AACA,4B;AACA,K;;AAEA,wD;AACA,kC;AACA,2B;AACA,qC;AACA,2B;AACA,4B;AACA,kC;;AAEA,2C;AACA,mB;AACA,mB;AACA,O;;AAEA,6D;AACA,6B;AACA,kB;;AAEA,2C;AACA,K;AACA,C","sourcesContent":["/**\r\n * Utility methods available privately to the package.\r\n */\r\n\r\nUtils = {};\r\n\r\n/**\r\n * Returns global on node or window in the browser.\r\n */\r\n\r\nUtils.global = function () {\r\n  if (typeof window !== 'undefined')\r\n    return window;\r\n  else if (typeof global !== 'undefined')\r\n    return global;\r\n  else\r\n    return null;\r\n};\r\n\r\n/**\r\n * Given the name of a property, resolves to the value. Works with namespacing\r\n * too. If first parameter is already a value that isn't a string it's returned\r\n * immediately.\r\n *\r\n * Examples:\r\n *  'SomeClass' => window.SomeClass || global.someClass\r\n *  'App.namespace.SomeClass' => window.App.namespace.SomeClass\r\n *\r\n * @param {String|Object} nameOrValue\r\n */\r\n\r\nUtils.resolveValue = function (nameOrValue) {\r\n  var global = Utils.global()\r\n    , parts\r\n    , ptr;\r\n\r\n  if (_.isString(nameOrValue)) {\r\n    parts = nameOrValue.split('.')\r\n    ptr = global;\r\n    for (var i = 0; i < parts.length; i++) {\r\n      ptr = ptr[parts[i]];\r\n      if (!ptr)\r\n        return undefined;\r\n    }\r\n  } else {\r\n    ptr = nameOrValue;\r\n  }\r\n\r\n  // final position of ptr should be the resolved value\r\n  return ptr;\r\n};\r\n\r\nUtils.hasOwnProperty = function (obj, key) {\r\n  var prop = {}.hasOwnProperty;\r\n  return prop.call(obj, key);\r\n};\r\n\r\n/**\r\n * Don't mess with this function. It's exactly the same as the compiled\r\n * coffeescript mechanism. If you change it we can't guarantee that our code\r\n * will work when used with Coffeescript. One exception is putting in a runtime\r\n * check that both child and parent are of type Function.\r\n */\r\n\r\nUtils.inherits = function (child, parent) {\r\n  if (Utils.typeOf(child) !== '[object Function]')\r\n    throw new Error('First parameter to Utils.inherits must be a function');\r\n   \r\n  if (Utils.typeOf(parent) !== '[object Function]')\r\n    throw new Error('Second parameter to Utils.inherits must be a function');\r\n\r\n  for (var key in parent) {\r\n    if (Utils.hasOwnProperty(parent, key))\r\n      child[key] = parent[key];\r\n  }\r\n\r\n  function ctor () {\r\n    this.constructor = child;\r\n  }\r\n\r\n  ctor.prototype = parent.prototype;\r\n  child.prototype = new ctor();\r\n  child.__super__ = parent.prototype;\r\n  return child;\r\n};\r\n\r\nUtils.toArray = function (obj) {\r\n  if (!obj)\r\n    return [];\r\n  else if (Utils.typeOf(obj) !== '[object Array]')\r\n    return [obj];\r\n  else\r\n    return obj;\r\n};\r\n\r\nUtils.typeOf = function (obj) {\r\n  if (obj && obj.typeName)\r\n    return obj.typeName;\r\n  else\r\n    return Object.prototype.toString.call(obj);\r\n};\r\n\r\nUtils.extend = function (Super, definition, onBeforeExtendPrototype) {\r\n  if (arguments.length === 1)\r\n    definition = Super;\r\n  else {\r\n    definition = definition || {};\r\n    definition.extend = Super;\r\n  }\r\n\r\n  return Utils.create(definition, {\r\n    onBeforeExtendPrototype: onBeforeExtendPrototype\r\n  });\r\n};\r\n\r\nUtils.create = function (definition, options) {\r\n  var Constructor\r\n    , extendFrom\r\n    , savedPrototype;\r\n\r\n  options = options || {};\r\n  definition = definition || {};\r\n\r\n  if (Utils.hasOwnProperty(definition, 'constructor'))\r\n    Constructor = definition.constructor;\r\n  else {\r\n    Constructor = function () {\r\n      if (Constructor.__super__ && Constructor.__super__.constructor)\r\n        return Constructor.__super__.constructor.apply(this, arguments);\r\n    }\r\n  }\r\n\r\n  extendFrom = definition.extend;\r\n\r\n  if (definition.extend) delete definition.extend;\r\n\r\n  var inherit = function (Child, Super, prototype) {\r\n    Utils.inherits(Child, Utils.resolveValue(Super));\r\n    if (prototype) _.extend(Child.prototype, prototype);\r\n  };\r\n\r\n  if (extendFrom) {\r\n    inherit(Constructor, extendFrom);\r\n  }\r\n\r\n  if (options.onBeforeExtendPrototype)\r\n    options.onBeforeExtendPrototype.call(Constructor, definition);\r\n\r\n  _.extend(Constructor.prototype, definition);\r\n\r\n  return Constructor;\r\n};\r\n\r\n/**\r\n * Assert that the given condition is truthy.\r\n *\r\n * @param {Boolean} condition The boolean condition to test for truthiness.\r\n * @param {String} msg The error message to show if the condition is falsy.\r\n */\r\n\r\nUtils.assert = function (condition, msg) {\r\n  if (!condition)\r\n    throw new Error(msg);\r\n};\r\n\r\nUtils.warn = function (condition, msg) {\r\n  if (!condition)\r\n    console && console.warn && console.warn(msg);\r\n};\r\n\r\nUtils.capitalize = function (str) {\r\n  return str[0].toUpperCase() + str.slice(1, str.length);\r\n};\r\n\r\nUtils.classify = function (str) {\r\n  var re = /_|-|\\./;\r\n  return _.map(str.split(re), function (word) {\r\n    return Utils.capitalize(word);\r\n  }).join('');\r\n};\r\n\r\nUtils.pick = function (/* args */) {\r\n  var args = _.toArray(arguments)\r\n    , arg;\r\n  for (var i = 0; i < args.length; i++) {\r\n    arg = args[i];\r\n    if (typeof arg !== 'undefined' && arg !== null)\r\n      return arg;\r\n  }\r\n\r\n  return null;\r\n};\r\n","/*\r\n * Inspiration and some code for the compilation of routes comes from pagejs.\r\n * The original has been modified to better handle hash fragments, and to store\r\n * the regular expression on the Route instance. Also, the resolve method has\r\n * been added to return a resolved path given a parameters object.\r\n */\r\n\r\nRoute = function (router, name, options) {\r\n  var path;\r\n\r\n  Utils.assert(router instanceof IronRouter);\r\n\r\n  Utils.assert(_.isString(name),\r\n    'Route constructor requires a name as the second parameter');\r\n\r\n  if (_.isFunction(options))\r\n    options = { handler: options };\r\n\r\n  options = this.options = options || {};\r\n  path = options.path || ('/' + name);\r\n\r\n  this.router = router;\r\n  this.originalPath = path;\r\n\r\n  if (_.isString(this.originalPath) && this.originalPath.charAt(0) !== '/')\r\n    this.originalPath = '/' + this.originalPath;\r\n\r\n  this.name = name;\r\n  this.where = options.where || 'client';\r\n  this.controller = options.controller;\r\n\r\n  if (typeof options.reactive !== 'undefined')\r\n    this.isReactive = options.reactive;\r\n  else\r\n    this.isReactive = true;\r\n\r\n  this.compile();\r\n};\r\n\r\nRoute.prototype = {\r\n  constructor: Route,\r\n\r\n  /**\r\n   * Compile the path. \r\n   *\r\n   *  @return {Route}\r\n   *  @api public\r\n   */\r\n\r\n  compile: function () {\r\n    var self = this\r\n      , path\r\n      , options = self.options;\r\n\r\n    this.keys = [];\r\n\r\n    if (self.originalPath instanceof RegExp) {\r\n      self.re = self.originalPath;\r\n    } else {\r\n      path = self.originalPath\r\n        .replace(/(.)\\/$/, '$1')\r\n        .concat(options.strict ? '' : '/?')\r\n        .replace(/\\/\\(/g, '(?:/')\r\n        .replace(/#/, '/?#')\r\n        .replace(\r\n          /(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g,\r\n          function (match, slash, format, key, capture, optional){\r\n            self.keys.push({ name: key, optional: !! optional });\r\n            slash = slash || '';\r\n            return ''\r\n              + (optional ? '' : slash)\r\n              + '(?:'\r\n              + (optional ? slash : '')\r\n              + (format || '') \r\n              + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\r\n              + (optional || '');\r\n          }\r\n        )\r\n        .replace(/([\\/.])/g, '\\\\$1')\r\n        .replace(/\\*/g, '(.*)');\r\n      \r\n      self.re = new RegExp('^' + path + '$', options.sensitive ? '' : 'i');\r\n    }\r\n\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Returns an array of parameters given a path. The array may have named\r\n   * properties in addition to indexed values.\r\n   *\r\n   * @param {String} path\r\n   * @return {Array}\r\n   * @api public\r\n   */\r\n\r\n  params: function (path) {\r\n    if (!path) return null;\r\n\r\n    var params = []\r\n      , m = this.exec(path)\r\n      , queryString\r\n      , keys = this.keys\r\n      , key\r\n      , value;\r\n\r\n    if (!m)\r\n      throw new Error('The route named \"' + this.name + '\" does not match the path \"' + path + '\"');\r\n\r\n    for (var i = 1, len = m.length; i < len; ++i) {\r\n      key = keys[i - 1];\r\n      value = typeof m[i] == 'string' ? decodeURIComponent(m[i]) : m[i];\r\n      if (key) {\r\n        params[key.name] = params[key.name] !== undefined ? \r\n          params[key.name] : value;\r\n      } else\r\n        params.push(value);\r\n    }\r\n\r\n    path = decodeURI(path);\r\n\r\n    queryString = path.split('?')[1];\r\n    if (queryString)\r\n      queryString = queryString.split('#')[0];\r\n\r\n    params.hash = path.split('#')[1];\r\n\r\n    if (queryString) {\r\n      _.each(queryString.split('&'), function (paramString) {\r\n        paramParts = paramString.split('=');\r\n        params[paramParts[0]] = decodeURIComponent(paramParts[1]);\r\n      });\r\n    }\r\n\r\n    return params;\r\n  },\r\n\r\n  normalizePath: function (path) {\r\n    var origin = Meteor.absoluteUrl();\r\n\r\n    path = path.replace(origin, '');\r\n\r\n    var queryStringIndex = path.indexOf('?');\r\n    path = ~queryStringIndex ? path.slice(0, queryStringIndex) : path;\r\n\r\n    var hashIndex = path.indexOf('#');\r\n    path = ~hashIndex ? path.slice(0, hashIndex) : path;\r\n\r\n    if (path.charAt(0) !== '/')\r\n      path = '/' + path;\r\n\r\n    return path;\r\n  },\r\n\r\n  /**\r\n   * Returns true if the path matches and false otherwise.\r\n   *\r\n   * @param {String} path\r\n   * @return {Boolean} \r\n   * @api public\r\n   */\r\n  test: function (path) {\r\n    return this.re.test(this.normalizePath(path));\r\n  },\r\n\r\n  exec: function (path) {\r\n    return this.re.exec(this.normalizePath(path));\r\n  },\r\n\r\n  resolve: function (params, options) {\r\n    var value\r\n      , isValueDefined\r\n      , result\r\n      , wildCardCount = 0\r\n      , path = this.originalPath\r\n      , hash\r\n      , query\r\n      , isMissingParams = false;\r\n\r\n    options = options || {};\r\n    params = params || [];\r\n    query = options.query;\r\n    hash = options.hash;\r\n\r\n    if (path instanceof RegExp) {\r\n      throw new Error('Cannot currently resolve a regular expression path');\r\n    } else {\r\n      path = this.originalPath\r\n        .replace(\r\n          /(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g,\r\n          function (match, slash, format, key, capture, optional) {\r\n            slash = slash || '';\r\n            value = params[key];\r\n            isValueDefined = typeof value !== 'undefined';\r\n\r\n            if (optional && !isValueDefined) {\r\n              slash = '';\r\n              value = '';\r\n            } else if (!isValueDefined) {\r\n              isMissingParams = true;\r\n              console.warn('You called Route.prototype.resolve with a missing parameter. \"' + key + '\" not found in params');\r\n              return;\r\n              //throw new Error('You called Route.prototype.resolve with a missing parameter. \"' + key + '\" not found in params');\r\n            }\r\n\r\n            value = _.isFunction(value) ? value.call(params) : value;\r\n            var escapedValue = _.map(String(value).split('/'), function (segment) {\r\n              return encodeURIComponent(segment);\r\n            }).join('/');\r\n            return slash + escapedValue\r\n          }\r\n        )\r\n        .replace(\r\n          /\\*/g,\r\n          function (match) {\r\n            if (typeof params[wildCardCount] === 'undefined') {\r\n              throw new Error(\r\n                'You are trying to access a wild card parameter at index ' + \r\n                wildCardCount +\r\n                ' but the value of params at that index is undefined');\r\n            }\r\n\r\n            var paramValue = String(params[wildCardCount++]);\r\n            return _.map(paramValue.split('/'), function (segment) {\r\n              return encodeURIComponent(segment);\r\n            }).join('/');\r\n          }\r\n        );\r\n\r\n      if (_.isObject(query)) {\r\n        query = _.map(_.pairs(query), function (queryPart) {\r\n          return queryPart[0] + '=' + encodeURIComponent(queryPart[1]);\r\n        }).join('&');\r\n\r\n        if (query && query.length)\r\n          path = path + '/?' + query;\r\n      }\r\n\r\n      if (hash) {\r\n        hash = encodeURI(hash.replace('#', ''));\r\n        path = query ? \r\n          path + '#' + hash : path + '/#' + hash;\r\n      }\r\n    }\r\n    \r\n    return isMissingParams ? '/' : path;\r\n  },\r\n\r\n  path: function (params, options) {\r\n    return this.resolve(params, options);\r\n  },\r\n\r\n  url: function (params, options) {\r\n    var path = this.path(params, options);\r\n    if (path[0] === '/')\r\n      path = path.slice(1, path.length);\r\n    return Meteor.absoluteUrl() + path;\r\n  },\r\n\r\n  getController: function (path, options) {\r\n    var self = this;\r\n    var handler\r\n      , controllerClass\r\n      , controller\r\n      , action\r\n      , routeName;\r\n\r\n    var resolveValue = Utils.resolveValue;\r\n    var classify = Utils.classify; \r\n    var toArray = Utils.toArray;\r\n\r\n    var findController = function (name) {\r\n      var controller = resolveValue(name);\r\n      if (typeof controller === 'undefined') {\r\n        throw new Error(\r\n          'controller \"' + name + '\" is not defined');\r\n      }\r\n\r\n      return controller;\r\n    };\r\n\r\n    options = _.extend({}, this.router.options, this.options, options || {}, {\r\n      before: toArray(this.options.before),\r\n      after: toArray(this.options.after),\r\n      unload: toArray(this.options.unload),\r\n      waitOn: toArray(this.router.options.waitOn)\r\n        .concat(toArray(this.options.waitOn)),\r\n      path: path,\r\n      route: this,\r\n      router: this.router,\r\n      params: this.params(path)\r\n    });\r\n    \r\n    // case 1: controller option is defined on the route\r\n    if (this.controller) {\r\n      controllerClass = _.isString(this.controller) ?\r\n        findController(this.controller) : this.controller;\r\n      controller = new controllerClass(options);\r\n      return controller;\r\n    }\r\n\r\n    // case 2: intelligently find the controller class in global namespace\r\n    routeName = this.name;\r\n\r\n    if (routeName) {\r\n      controllerClass = resolveValue(classify(routeName + 'Controller'));\r\n\r\n      if (controllerClass) {\r\n        controller = new controllerClass(options);\r\n        return controller;\r\n      }\r\n    }\r\n\r\n    // case 3: nothing found so create an anonymous controller\r\n    return new RouteController(options);\r\n  }\r\n};\r\n","/*****************************************************************************/\r\n/* IronRouteController */\r\n/*****************************************************************************/\r\n\r\n/**\r\n * Base class for client and server RouteController.\r\n */\r\n\r\nIronRouteController = function (options) {\r\n  var self = this;\r\n\r\n  options = this.options = options || {};\r\n\r\n  var getOption = function (key) {\r\n    return Utils.pick(self.options[key], self[key]);\r\n  };\r\n\r\n  this.router = options.router;\r\n  this.route = options.route;\r\n  this.path = options.path;\r\n  this.params = options.params || [];\r\n  this.where = options.where || 'client';\r\n  this.action = options.action || this.action;\r\n  this.hooks = {};\r\n\r\n  options.load = Utils.toArray(options.load);\r\n  options.before = Utils.toArray(options.before);\r\n  options.after = Utils.toArray(options.after);\r\n  options.unload = Utils.toArray(options.unload);\r\n};\r\n\r\nIronRouteController.prototype = {\r\n  constructor: IronRouteController,\r\n  \r\n  runHooks: function (hookName, more) {\r\n    var ctor = this.constructor\r\n      , more = Utils.toArray(more);\r\n\r\n    var collectInheritedHooks = function (ctor) {\r\n      var hooks = [];\r\n\r\n      if (ctor.__super__)\r\n        hooks = hooks.concat(collectInheritedHooks(ctor.__super__.constructor));\r\n      \r\n      return ctor.prototype[hookName] ?\r\n        hooks.concat(ctor.prototype[hookName]) : hooks;\r\n    };\r\n\r\n    var prototypeHooks = collectInheritedHooks(this.constructor);\r\n    var routeHooks = this.options[hookName];\r\n    var globalHooks = \r\n      this.route ? this.router.getHooks(hookName, this.route.name) : [];\r\n\r\n    var allHooks = globalHooks.concat(routeHooks).concat(prototypeHooks).concat(more);\r\n\r\n    for (var i = 0, hook; hook = allHooks[i]; i++) {\r\n      if (this.stopped)\r\n        break;\r\n      hook.call(this);\r\n    }\r\n  },\r\n\r\n  run: function () {\r\n    throw new Error('not implemented');\r\n  },\r\n\r\n  action: function () {\r\n    throw new Error('not implemented');\r\n  },\r\n\r\n  stop: function() {\r\n    this.stopped = true;\r\n  }\r\n};\r\n\r\n_.extend(IronRouteController, {\r\n  /**\r\n   * Inherit from IronRouteController\r\n   *\r\n   * @param {Object} definition Prototype properties for inherited class.\r\n   */\r\n\r\n  extend: function (definition) {\r\n    return Utils.extend(this, definition, function (definition) {\r\n      var klass = this;\r\n      \r\n      /*\r\n        Allow calling a class method from javascript, directly in the subclass\r\n        definition.\r\n\r\n        Instead of this:\r\n          MyController = RouteController.extend({...});\r\n          MyController.before(function () {});\r\n\r\n        You can do:\r\n          MyController = RouteController.extend({\r\n            before: function () {}\r\n          });\r\n       \r\n        And in Coffeescript you can do:\r\n         MyController extends RouteController\r\n           @before function () {}\r\n       */\r\n    });\r\n  }\r\n});\r\n","/*****************************************************************************/\r\n/* IronRouter */\r\n/*****************************************************************************/\r\nIronRouter = function (options) {\r\n  var self = this;\r\n  \r\n  this.configure(options);\r\n\r\n  /**\r\n   * The routes array which doubles as a named route index by adding\r\n   * properties to the array.\r\n   *\r\n   * @api public\r\n   */\r\n  this.routes = [];\r\n  \r\n  this._globalHooks = {};\r\n  _.each(IronRouter.HOOK_TYPES, function(type) { self._globalHooks[type] = []; });\r\n};\r\n\r\nIronRouter.HOOK_TYPES = ['load', 'before', 'after', 'unload'];\r\n\r\nIronRouter.prototype = {\r\n  constructor: IronRouter,\r\n\r\n  /**\r\n   * Configure instance with options. This can be called at any time. If the\r\n   * instance options object hasn't been created yet it is created here.\r\n   *\r\n   * @param {Object} options\r\n   * @return {IronRouter}\r\n   * @api public\r\n   */\r\n  \r\n  configure: function (options) {\r\n    var self = this;\r\n    \r\n    this.options = this.options || {};\r\n    _.extend(this.options, options);\r\n    \r\n    // e.g. before: fn OR before: [fn1, fn2]\r\n    _.each(IronRouter.HOOK_TYPES, function(type) {\r\n      if (self.options[type]) {\r\n        _.each(Utils.toArray(self.options[type]), function(hook) {\r\n          self.addHook(type, hook);\r\n        });\r\n        \r\n        delete self.options[type];\r\n      }\r\n    });\r\n    \r\n    return this;\r\n  },\r\n\r\n\r\n  /**\r\n   *\r\n   * Add a hook to all routes. The hooks will apply to all routes,\r\n   * unless you name routes to include or exclude via `only` and `except` options\r\n   *\r\n   * @param {String} [type] one of 'load', 'unload', 'before' or 'after'\r\n   * @param {Object} [options] Options to controll the hooks [optional]\r\n   * @param {Function} [hook] Callback to run\r\n   * @return {IronRouter}\r\n   * @api public\r\n   *\r\n   */\r\n  \r\n  addHook: function(type, hook, options) {\r\n    options = options || {}\r\n\r\n    if (options.only)\r\n      options.only = Utils.toArray(options.only);\r\n    if (options.except)\r\n      options.except = Utils.toArray(options.except);\r\n      \r\n    this._globalHooks[type].push({options: options, hook: hook});\r\n    \r\n    return this;\r\n  },\r\n  \r\n  load: function(hook, options) {\r\n    return this.addHook('load', hook, options);\r\n  },\r\n\r\n  before: function(hook, options) {\r\n    return this.addHook('before', hook, options);\r\n  },\r\n  \r\n  after: function(hook, options) {\r\n    return this.addHook('after', hook, options);\r\n  },\r\n  \r\n  unload: function(hook, options) {\r\n    return this.addHook('unload', hook, options);\r\n  },\r\n  \r\n  /**\r\n   *\r\n   * Fetch the list of global hooks that apply to the given route name.\r\n   * Hooks are defined by the .addHook() function above.\r\n   *\r\n   * @param {String} [type] one of 'load', 'unload', 'before' or 'after'\r\n   * @param {String} [name] the name of the route we are interested in\r\n   * @return {[Function]} [hooks] an array of hooks to run\r\n   * @api public\r\n   *\r\n   */\r\n    \r\n  getHooks: function(type, name) {\r\n    var hooks = [];\r\n    \r\n    _.each(this._globalHooks[type], function(hook) {\r\n      var options = hook.options;\r\n      \r\n      if (options.except && _.include(options.except, name))\r\n        return;\r\n      \r\n      if (options.only && ! _.include(options.only, name))\r\n        return;\r\n      \r\n      hooks.push(hook.hook);\r\n    });\r\n    \r\n    return hooks;\r\n  },\r\n  \r\n\r\n  /**\r\n   * Convenience function to define a bunch of routes at once. In the future we\r\n   * might call the callback with a custom dsl.\r\n   *\r\n   * Example:\r\n   *  Router.map(function () {\r\n   *    this.route('posts');\r\n   *  });\r\n   *\r\n   *  @param {Function} cb\r\n   *  @return {IronRouter}\r\n   *  @api public\r\n   */\r\n\r\n  map: function (cb) {\r\n    Utils.assert(_.isFunction(cb),\r\n           'map requires a function as the first parameter');\r\n    cb.call(this);\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Define a new route. You must name the route, but as a second parameter you\r\n   * can either provide an object of options or a Route instance.\r\n   *\r\n   * @param {String} name The name of the route\r\n   * @param {Object} [options] Options to pass along to the route\r\n   * @return {Route}\r\n   * @api public\r\n   */\r\n\r\n  route: function (name, options) {\r\n    var route;\r\n\r\n    Utils.assert(_.isString(name), 'name is a required parameter');\r\n    \r\n    if (options instanceof Route)\r\n      route = options;\r\n    else\r\n      route = new Route(this, name, options);\r\n\r\n    this.routes[name] = route;\r\n    this.routes.push(route);\r\n    return route;\r\n  },\r\n\r\n  path: function (routeName, params, options) {\r\n    var route = this.routes[routeName];\r\n    Utils.warn(route,\r\n     'You called Router.path for a route named ' + routeName + ' but that that route doesn\\'t seem to exist. Are you sure you created it?');\r\n    return route && route.path(params, options);\r\n  },\r\n\r\n  url: function (routeName, params, options) {\r\n    var route = this.routes[routeName];\r\n    Utils.warn(route, \r\n      'You called Router.url for a route named \"' + routeName + '\" but that route doesn\\'t seem to exist. Are you sure you created it?');\r\n    return route && route.url(params, options);\r\n  },\r\n\r\n  dispatch: function (path, options, cb) {\r\n    var self = this\r\n      , routes = self.routes\r\n      , route\r\n      , controller\r\n      , where = Meteor.isClient ? 'client' : 'server'\r\n      , i = 0;\r\n\r\n    function next () {\r\n      route = routes[i++];\r\n\r\n      if (!route) {\r\n        return self.onRouteNotFound(path, options);\r\n      }\r\n\r\n      if (route.test(path)) {\r\n        if (route.where !== where) \r\n          return self.onUnhandled(path, options);\r\n\r\n        var controller = route.getController(path, options);\r\n        self.run(controller, cb);\r\n      } else {\r\n        next();\r\n      }\r\n    }\r\n\r\n    next();\r\n  },\r\n\r\n  run: function (controller, cb) {\r\n    throw new Error('run not implemented');\r\n  },\r\n\r\n  onUnhandled: function (path, options) {\r\n    throw new Error('onUnhandled not implemented');\r\n  },\r\n\r\n  onRouteNotFound: function (path, options) {\r\n    throw new Error('Oh no! No route found for path: \"' + path + '\"');\r\n  }\r\n};\r\n","var dep = new Deps.Dependency;\r\nvar popped = false;\r\n\r\nfunction onclick (e) {\r\n  var el = e.currentTarget;\r\n  var which = _.isUndefined(e.which) ? e.button : e.which;\r\n  var href = el.href;\r\n  var path = el.pathname + el.search + el.hash;\r\n\r\n  // we only want to handle clicks on links which:\r\n  //  - are with the left mouse button with no meta key pressed\r\n  if (which !== 1)\r\n    return;\r\n\r\n  if (e.metaKey || e.ctrlKey || e.shiftKey) \r\n    return;\r\n  \r\n  // - haven't been cancelled already\r\n  if (e.isDefaultPrevented())\r\n    return;\r\n  \r\n  // - aren't in a new window\r\n  if (el.target)\r\n    return;\r\n  \r\n  // - aren't external to the app\r\n  if (!IronLocation.isSameOrigin(href)) \r\n    return;\r\n  \r\n  // note that we _do_ handle links which point to the current URL\r\n  // and links which only change the hash.\r\n  e.preventDefault();\r\n  IronLocation.set(path);\r\n}\r\n\r\nfunction onpopstate (e) {\r\n  if (popped)\r\n    dep.changed();\r\n}\r\n\r\nIronLocation = {};\r\n\r\nIronLocation.origin = function () {\r\n  return location.protocol + '//' + location.host;\r\n};\r\n\r\nIronLocation.isSameOrigin = function (href) {\r\n  var origin = IronLocation.origin();\r\n  return href.indexOf(origin) === 0;\r\n};\r\n\r\nIronLocation.get = function () {\r\n  dep.depend();\r\n  return location;\r\n};\r\n\r\nIronLocation.path = function () {\r\n  dep.depend();\r\n  return location.pathname + location.search + location.hash;\r\n};\r\n\r\nIronLocation.set = function (url, options) {\r\n  options = options || {};\r\n\r\n  var state = options.state || {};\r\n\r\n  if (/^http/.test(url))\r\n    href = url;\r\n  else {\r\n    if (url.charAt(0) !== '/')\r\n      url = '/' + url;\r\n    href = IronLocation.origin() + url;\r\n  }\r\n\r\n  if (!IronLocation.isSameOrigin(href))\r\n    window.location = href;\r\n  else if (options.where === 'server')\r\n    window.location = href;\r\n  else if (options.replaceState)\r\n    IronLocation.replaceState(state, options.title, url);\r\n  else\r\n    IronLocation.pushState(state, options.title, url);\r\n\r\n  if (options.skipReactive !== true)\r\n    dep.changed();\r\n};\r\n\r\nIronLocation.pushState = function (state, title, url) {\r\n  popped = true;\r\n  if (history.pushState)\r\n    history.pushState(state, title, url);\r\n  else\r\n    window.location = url;\r\n};\r\n\r\nIronLocation.replaceState = function (state, title, url) {\r\n  popped = true;\r\n  if (history.replaceState)\r\n    history.replaceState(state, title, url);\r\n  else\r\n    window.location = url;\r\n};\r\n\r\nIronLocation.start = function () {\r\n  if (this.isStarted)\r\n    return;\r\n\r\n  $(window).on('popstate', onpopstate);\r\n  $(document).on('click', 'a[href]', onclick);\r\n  this.isStarted = true;\r\n  \r\n  // store the fact that this is the first route we hit.\r\n  // this serves two purposes\r\n  //   1. We can tell when we've reached an unhandled route and need to show a\r\n  //      404 (rather than bailing out to let the server handle it)\r\n  //   2. Users can look at the state to tell if the history.back() will stay\r\n  //      inside the app (this is important for mobile apps).\r\n  if (history.replaceState)\r\n    history.replaceState({initial: true}, null, location.pathname + location.search)\r\n};\r\n\r\nIronLocation.stop = function () {\r\n  $(window).off('popstate', onpopstate);\r\n  $(window).off('click', 'a[href]', onclick);\r\n  this.isStarted = false;\r\n};\r\n\r\nIronLocation.start();\r\n","var MAIN_YIELD = '__main__';\r\nvar DEFAULT_LAYOUT = '__defaultLayout__';\r\n\r\nvar getTemplateFunction = function (template, defaultFn) {\r\n  if (_.isFunction(template))\r\n    return template;\r\n  else if (Template[template])\r\n    return Template[template];\r\n  else if (defaultFn)\r\n    return defaultFn;\r\n  else\r\n    throw new Error('Oops, no template found named \"' + template + '\"');\r\n};\r\n\r\nvar assertTemplateExists = function (template) {\r\n  if (_.isFunction(template))\r\n    return true;\r\n  else if (!Template[template])\r\n    throw new Error('Uh oh, no template found named \"' + template + '\"');\r\n};\r\n\r\nvar ReactiveVar = function (value) {\r\n  this._dep = new Deps.Dependency;\r\n  this._value = value || null;\r\n};\r\n\r\nReactiveVar.prototype = {\r\n  set: function (value) {\r\n    if (EJSON.equals(value, this._value))\r\n      return;\r\n\r\n    this._value = value;\r\n    this._dep.changed();\r\n  },\r\n\r\n  get: function () {\r\n    this._dep.depend();\r\n    return this._value;\r\n  },\r\n\r\n  equals: function (other) {\r\n    this._dep.depend();\r\n    return EJSON.equals(this._value, other);\r\n  }\r\n};\r\n\r\nPageManager = function () {\r\n  this.yieldsToTemplates = new ReactiveDict;\r\n  this.layout = new ReactiveVar;\r\n  this.data = new ReactiveVar({});\r\n  this.layout.set(DEFAULT_LAYOUT);\r\n  this._yields = {};\r\n};\r\n\r\nPageManager.prototype = {\r\n  constructor: PageManager,\r\n\r\n  setLayout: function (layout) {\r\n    var self = this;\r\n    layout = layout || DEFAULT_LAYOUT;\r\n    assertTemplateExists(layout);\r\n    Deps.nonreactive(function () {\r\n      var oldLayout = self.layout.get();\r\n\r\n      // reset because we have a new layout now\r\n      if (oldLayout !== layout)\r\n        self._yields = {};\r\n    });\r\n\r\n    this.layout.set(layout);\r\n  },\r\n\r\n  setTemplate: function (template, to) {\r\n    var self = this;\r\n\r\n    to = to || MAIN_YIELD;\r\n\r\n    // make sure the yield region was declared otherwise the user may have\r\n    // tried to render into a named yield that was never declared in the\r\n    // layout. Let's provide them a helpful warning if that happens.\r\n\r\n    // If we're already in a flush we want to schedule the yield check for after\r\n    // the next flush, not this one. The flush we're currently in is caused by a\r\n    // location change which triggers the router's dispatch process. Then, we\r\n    // add this check to the current flush's afterFlushCallbacks queue which\r\n    // caues it to be executed as soon as all our code is done running, instead\r\n    // of after the next flush which is what we want. There might be a better\r\n    // pattern here.\r\n    Meteor.defer(function () {\r\n      Deps.afterFlush(function () {\r\n        var isYieldDeclared = self._yields[to];\r\n        var help;\r\n\r\n        if (!isYieldDeclared) {\r\n          if (to == MAIN_YIELD)\r\n            help = 'Sorry, couldn\\'t find the main yield. Did you define it in one of the rendered templates like this: {{yield}}?';\r\n          else\r\n            help = 'Sorry, couldn\\'t find a yield named \"' + to + '\". Did you define it in one of the rendered templates like this: {{yield \"' + to + '\"}}?';\r\n\r\n          if (console && console.warn)\r\n            console.warn(help);\r\n          else if (console && console.error)\r\n            console.error(help);\r\n          else\r\n            throw new Error(help);\r\n        }\r\n      });\r\n    });\r\n\r\n    this.yieldsToTemplates.set(to, template);\r\n  },\r\n\r\n  clearYield: function (key) {\r\n    this.yieldsToTemplates.set(key, null);\r\n  },\r\n\r\n  setData: function (data) {\r\n    this.data.set(data);\r\n  },\r\n\r\n  getData: function () {\r\n    return this.data.get();\r\n  },\r\n\r\n  helpers: function () {\r\n    var self = this;\r\n    return {\r\n      'yield': function (key, options) {\r\n        var html;\r\n\r\n        if (arguments.length < 2)\r\n          key = null;\r\n\r\n        html = self._renderTemplate(key);\r\n        return new Handlebars.SafeString(html);\r\n      }\r\n    };\r\n  },\r\n\r\n  _renderTemplate: function (key) {\r\n    var self = this;\r\n\r\n    key = key || MAIN_YIELD;\r\n\r\n    // register that this named yield was used so we can check later that all\r\n    // setTemplate calls were for a yield region that exists.\r\n    this._yields[key] = true;\r\n\r\n\r\n    return Spark.isolate(function () {\r\n      // grab the template function from Template or just make the template\r\n      // function return an empty string if no template found\r\n      var template = getTemplateFunction(self.yieldsToTemplates.get(key), function () {\r\n        return '';\r\n      });\r\n\r\n      var data = self.getData();\r\n      var helpers = self.helpers();\r\n      var dataContext = _.extend({}, data, helpers);\r\n\r\n      return template(dataContext);\r\n    });\r\n  },\r\n\r\n  renderLayout: function () {\r\n    var self = this;\r\n\r\n    var html = Spark.isolate(function () {\r\n      var layout = getTemplateFunction(self.layout.get());\r\n      var data = self.data.get();\r\n      var helpers = self.helpers();\r\n      var dataContext = _.extend({}, data, helpers);\r\n      return layout(dataContext);\r\n    });\r\n\r\n    return html;\r\n  },\r\n\r\n  clearUnusedYields: function (usedYields) {\r\n    var self = this;\r\n    var allYields = _.keys(this.yieldsToTemplates.keys);\r\n\r\n    usedYields = _.filter(usedYields, function (val) {\r\n      return !!val;\r\n    });\r\n\r\n    var unusedYields = _.difference(allYields, usedYields);\r\n\r\n    _.each(unusedYields, function (key) {\r\n      self.clearYield(key);\r\n    });\r\n  }\r\n};\r\n","/**\r\n * Client side router.\r\n *\r\n * @class ClientRouter\r\n * @exports ClientRouter\r\n * @extends IronRouter\r\n */\r\n\r\nClientRouter = Utils.extend(IronRouter, {\r\n  /**\r\n   * @constructor\r\n   * @param {Object} [options]\r\n   * @param {Boolean} [options.autoRender] Automatically render to the body\r\n   * @param {Boolean} [options.autoStart] Automatically start listening to\r\n   * events\r\n   */\r\n\r\n  constructor: function (options) {\r\n    var self = this;\r\n\r\n    ClientRouter.__super__.constructor.apply(this, arguments);\r\n\r\n    this.isRendered = false;\r\n\r\n    this._page = new PageManager;\r\n\r\n    /**\r\n     * The current RouteController instance. This is set anytime a new route is\r\n     * dispatched. It's a reactive variable which you can get by calling\r\n     * Router.current();\r\n     *\r\n     * @api private\r\n     */\r\n    this._currentController = null;\r\n\r\n    /**\r\n     * Dependency to for this._currentController\r\n     *\r\n     * @api private\r\n     */\r\n    this._controllerDep = new Deps.Dependency;\r\n\r\n    /**\r\n      * Did the URL we are looking at come from a hot-code-reload \r\n      *  (and thus should we treat is as not new?)\r\n      * \r\n      * @api private\r\n      */\r\n    this._hasJustReloaded = false;\r\n\r\n    Meteor.startup(function () {\r\n      setTimeout(function () {\r\n        if (self.options.autoRender !== false)\r\n          self.autoRender();\r\n        if (self.options.autoStart !== false)\r\n          self.start();\r\n      });\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Reactive accessor for the current RouteController instance. You can also\r\n   * get a nonreactive value by specifiying {reactive: false} as an option.\r\n   *\r\n   * @param {Object} [opts] configuration options\r\n   * @param {Boolean} [opts.reactive] Set to false to enable a non-reactive read.\r\n   * @return {RouteController}\r\n   * @api public\r\n   */\r\n\r\n  current: function (opts) {\r\n    if (opts && opts.reactive === false)\r\n      return this._currentController;\r\n    else {\r\n      this._controllerDep.depend();\r\n      return this._currentController;\r\n    }\r\n  },\r\n\r\n  setLayout: function (layout) {\r\n    this._page.setLayout(layout);\r\n  },\r\n\r\n  setTemplate: function (template, to) {\r\n    this._page.setTemplate(template, to);\r\n  },\r\n\r\n  clearUnusedYields: function (usedYields) {\r\n    this._page.clearUnusedYields(usedYields);\r\n  },\r\n\r\n  setData: function (data) {\r\n    this._page.setData(data);\r\n  },\r\n\r\n  getData: function () {\r\n    return this._page.getData();\r\n  },\r\n\r\n  run: function (controller, cb) {\r\n    var self = this;\r\n    var where = Meteor.isClient ? 'client' : 'server';\r\n\r\n    Utils.assert(controller, 'run requires a controller');\r\n\r\n    // one last check to see if we should handle the route here\r\n    if (controller.where != where) {\r\n      self.onUnhandled(controller.path, controller.options);\r\n      return;\r\n    }\r\n\r\n    var runRouteController = function () {\r\n      Deps.autorun(function (c) {\r\n        self._routeComputation = c;\r\n        \r\n        if (! self._hasJustReloaded)\r\n          controller.runHooks('load');\r\n        self._hasJustReloaded = false;\r\n        \r\n        Deps.autorun(function () {\r\n          controller.run();\r\n        });\r\n      });\r\n    };\r\n\r\n    if (this._currentController)\r\n      this._currentController.runHooks('unload');\r\n\r\n    this._currentController = controller;\r\n\r\n    if (this._routeComputation) {\r\n      this._routeComputation.stop();\r\n      this._routeComputation.onInvalidate(runRouteController);\r\n    } else {\r\n      runRouteController();\r\n    }\r\n\r\n    if (controller == this._currentController) {\r\n      cb && cb(controller);\r\n      this._controllerDep.changed();\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Wrapper around Location.go that accepts a routeName or a path as the first\r\n   * parameter. This method can accept client and server side routes.\r\n   *\r\n   * Examples:\r\n   *\r\n   *  1. Router.go('/posts', {state: 'true'});\r\n   *  2. Router.go('postIndex', [param1, param2], {state});\r\n   *\r\n   * @param {String} routeNameOrPath\r\n   * @param {Array|Object} [params]\r\n   * @param {Object} [state]\r\n   * @param {Boolean} [replaceState]\r\n   * @api public\r\n   */\r\n\r\n  go: function (routeNameOrPath, params, options) {\r\n    var isPathRe = /^\\/|http/\r\n      , route\r\n      , path\r\n      , onComplete\r\n      , controller\r\n      , done = function() {\r\n        options = options || {};\r\n        IronLocation.set(path, {\r\n          replaceState: options.replaceState,\r\n          state: options.state,\r\n          skipReactive: true\r\n        });\r\n      };\r\n\r\n    if (isPathRe.test(routeNameOrPath)) {\r\n      path = routeNameOrPath;\r\n      options = params;\r\n      // issue here is in the dispatch process we might want to\r\n      // make a server request so therefore not call this method yet, so\r\n      // we need to push the state only after we've decided it's a client\r\n      // request, otherwise let the browser handle it and send off to the\r\n      // server\r\n      this.dispatch(path, options, done);\r\n    } else {\r\n      route = this.routes[routeNameOrPath];\r\n      Utils.assert(route, 'No route found named ' + routeNameOrPath);\r\n      path = route.path(params, options);\r\n      controller = route.getController(path, options);\r\n      this.run(controller, done);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Returns an html string or a document fragment with the router's layout.\r\n   * This method also sets up the 'yield' helper on the layout. This is so that\r\n   * the yield helper has a reference to the router through the closure.\r\n   *\r\n   * @returns {String|DocumentFragment}\r\n   * @api public\r\n   */\r\n\r\n  render: function () {\r\n    this.isRendered = true;\r\n    return this._page.renderLayout();\r\n  },\r\n\r\n  /**\r\n   * Render the router into the body of the page automatically. Calles the\r\n   * render method inside Spark.render to create a renderer and appends to the\r\n   * document body.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  autoRender: function () {\r\n    var self = this;\r\n    var frag = Spark.render(function () {\r\n      return self.render();\r\n    });\r\n    document.body.appendChild(frag);\r\n  },\r\n\r\n\r\n  /**\r\n   * Start listening to click events and set up a Deps.autorun for location\r\n   * changes. If already started the method just returns.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  start: function () {\r\n    var self = this;\r\n\r\n    if (self.isStarted) return;\r\n\r\n    self.isStarted = true;\r\n    \r\n    Deps.autorun(function (c) {\r\n      var location;\r\n      self._locationComputation = c;\r\n      self.dispatch(IronLocation.path(), {state: history.state});\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Remove click event listener and stop listening for location changes.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  stop: function () {\r\n    this.isStarted = false;\r\n\r\n    if (this._locationComputation)\r\n      this._locationComputation.stop();\r\n  },\r\n\r\n  /**\r\n   * If we don't handle a link but the server does, bail to the server\r\n   *\r\n   * @api public\r\n   */\r\n  onUnhandled: function (path, options) {\r\n    this.stop();\r\n    window.location = path;\r\n  },\r\n  \r\n  /**\r\n   * if we don't handle a link, _and_ the server doesn't handle it,\r\n   * do one of two things:\r\n   *   a) if this is the initial route, then it can't be a static asset, so \r\n   *      show notFound or throw an error\r\n   *   b) otherwise, let the server have a go at it, we may end up coming back.\r\n   *\r\n   * @api public\r\n   */\r\n  onRouteNotFound: function (path, options) {\r\n    if (history && ! history.state.initial) {\r\n      this.stop();\r\n      window.location = path;\r\n    } else if (this.options.notFoundTemplate) {\r\n      this.setLayout(this.options.layoutTemplate);\r\n      this.setTemplate(this.options.notFoundTemplate);\r\n    } else {\r\n      throw new Error('Oh no! No route found for path: \"' + path + '\"');\r\n    }\r\n  }\r\n});\r\n\r\n/**\r\n * The main Router instance that clients will deal with\r\n *\r\n * @api public\r\n * @exports Router\r\n */\r\n\r\nRouter = new ClientRouter;\r\n\r\nif (Meteor._reload) {\r\n  // just register the fact that a migration _has_ happened\r\n  Meteor._reload.onMigrate('iron-router', function() { return [true, true]});\r\n  \r\n  // then when we come back up, check if it it's set\r\n  var data = Meteor._reload.migrationData('iron-router');\r\n  Router._hasJustReloaded = data;\r\n}","Template.__define__(\"__defaultLayout__\",Package.handlebars.Handlebars.json_ast_to_func([[\"{\",[[0,\"yield\"]]]]));\n","/*****************************************************************************/\r\n/* WaitList */\r\n/*****************************************************************************/\r\nWaitList = function () {\r\n  this._dep = new Deps.Dependency;\r\n  this.clear();\r\n};\r\n\r\nWaitList.prototype = {\r\n  get: function (idx) {\r\n    return this._list[idx];\r\n  },\r\n\r\n  clear: function () {\r\n    this._list = [];\r\n  },\r\n\r\n  append: function (list) {\r\n    var self = this;\r\n    list = Utils.toArray(list);\r\n    _.each(list, function (o) {\r\n      self.push(o);\r\n    });\r\n  },\r\n\r\n  push: function (o) {\r\n    var self = this;\r\n\r\n    if (!o)\r\n      return;\r\n\r\n    var res = this._list.push(o);\r\n\r\n    return res;\r\n  },\r\n\r\n  ready: function () {\r\n    return _.all(this._list, function (handle) {\r\n      return handle.ready();\r\n    });\r\n  }\r\n};\r\n\r\n/*****************************************************************************/\r\n/* Predefined Hooks */\r\n/*****************************************************************************/\r\nvar setDataHook = function () {\r\n  var self = this;\r\n  var data = _.isFunction(self.data) ? self.data.call(self) : self.data;\r\n  if (data !== false) {\r\n    self.setData(data);\r\n  }\r\n};\r\n\r\nvar autoRenderNotFoundTemplateHook = function () {\r\n  var self = this;\r\n  var data = self.getData();\r\n  if ((data === null || typeof data === 'undefined') \r\n      && self.notFoundTemplate) {\r\n    self.render(self.notFoundTemplate);\r\n    this.renderYields();\r\n    self.stop();\r\n  }\r\n};\r\n\r\nvar autoRenderLoadingTemplateHook = function () {\r\n  var self = this;\r\n\r\n  if (!this.ready()) {\r\n    if (this.loadingTemplate) {\r\n      this.render(this.loadingTemplate);\r\n      this.renderYields();\r\n      this.stop();\r\n    }\r\n  }\r\n};\r\n\r\nvar autoClearUnusedYieldsHook = function () {\r\n  this.router && this.router.clearUnusedYields(this._renderedYields);\r\n};\r\n\r\n/*****************************************************************************/\r\n/* RouteController */\r\n/*****************************************************************************/\r\nRouteController = Utils.extend(IronRouteController, {\r\n  constructor: function () {\r\n    RouteController.__super__.constructor.apply(this, arguments);\r\n\r\n    var self = this;\r\n\r\n    var getOption = function (key) {\r\n      return Utils.pick(self.options[key], self[key]);\r\n    };\r\n\r\n    this.loadingTemplate = getOption('loadingTemplate');\r\n    this.notFoundTemplate = getOption('notFoundTemplate');\r\n    this.data = getOption('data');\r\n    this.template = getOption('template') || (this.route && this.route.name);\r\n    this.yieldTemplates = getOption('yieldTemplates');\r\n    this.layoutTemplate = getOption('layoutTemplate');\r\n    \r\n    /*\r\n     * waitOn can come from the options or the prototype. We add the option\r\n     * waitOn value first and then concatenate the prototype waitOn value.\r\n     * Possible values are:\r\n     *\r\n     * Router.configure({\r\n     *  waitOn: Meteor.subscribe('items')\r\n     * });\r\n     *\r\n     * Router.route('someRoute', {\r\n     *  waitOn: function () {\r\n     *    return Meteor.subscribe('item', this.params._id);\r\n     *  }\r\n     * });\r\n     *\r\n     * waitOn => [{}, fn]\r\n     *  fn => could return an object or another array of objects\r\n     * \r\n     */\r\n    this.waitOn = []\r\n      .concat(Utils.toArray(this.options.waitOn))\r\n      .concat(Utils.toArray(this.waitOn));\r\n\r\n    this._waitList = new WaitList;\r\n  },\r\n\r\n  ready: function () {\r\n    return this._waitList.ready();\r\n  },\r\n\r\n  /**\r\n   * Stop running this controller and redirect to a new path. Same parameters as\r\n   * those of Router.go.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  redirect: function (/* args */) {\r\n    this.stop();\r\n    return this.router && this.router.go.apply(this.router, arguments);\r\n  },\r\n\r\n  /**\r\n   * Used to specify additional templates to render into named yield regions.\r\n   * The default run method will first render the main template and then use\r\n   * this property to render additional templates. Only used in the 'run'\r\n   * method.\r\n   *\r\n   * Example:\r\n   *\r\n   *  yieldTemplates: {\r\n   *    'asideTemplateName': {to: 'aside', data: {}, waitOn: Sub},\r\n   *    'footerTemplateName': {to: 'footer'}\r\n   *  }\r\n   *\r\n   * @type {Object|null}\r\n   * @api public\r\n   */\r\n\r\n  yieldTemplates: null,\r\n\r\n  layoutTemplate: null,\r\n\r\n  /**\r\n   * The default template to render\r\n   *\r\n   * @type {String|Function}\r\n   * @api public\r\n   */\r\n\r\n  template: null,\r\n\r\n  /**\r\n   * Optional template to be used while waiting. If specified, the loading\r\n   * template is used automatically in the run method. You can also use it\r\n   * manually.\r\n   *\r\n   * @type {String|Function}\r\n   * @api public\r\n   */\r\n\r\n  loadingTemplate: null,\r\n\r\n  /**\r\n   * Optional template to be used if data returns a falsy value. Used\r\n   * automatically in the run method. You can also use it manually.\r\n   *\r\n   * @type {String|Function}\r\n   * @api public\r\n   */\r\n\r\n  notFoundTemplate: null,\r\n\r\n  /**\r\n   * A default data object or function to be used as the data context in\r\n   * rendering.\r\n   *\r\n   * @type {Object|Function}\r\n   * @api public\r\n   */\r\n\r\n  data: {},\r\n\r\n  getData: function () {\r\n    return this.router && this.router.getData();\r\n  },\r\n\r\n  setData: function (data) {\r\n    this.router && this.router.setData(data);\r\n  },\r\n\r\n  waitOn: null,\r\n\r\n  /*\r\n   * Calls Meteor.subscribe but adds a wait method to the returned handle\r\n   * object. If the user calls wait on the result, the subscription handle is\r\n   * added to the RouteController's wait list.\r\n   */\r\n\r\n  subscribe: function (/* same as Meteor.subscribe */) {\r\n    var self = this;\r\n\r\n    var waitApi = (function () {\r\n      var added = false;\r\n\r\n      return {\r\n        wait: function () {\r\n          // make idempotent\r\n          if (!added) {\r\n            self._waitList.push(this);\r\n            added = true;\r\n          }\r\n        }\r\n      };\r\n    })();\r\n\r\n    var handle = Meteor.subscribe.apply(this, arguments);\r\n    return _.extend(handle, waitApi);\r\n  },\r\n\r\n  /**\r\n   * Either specify a template to render or call with no arguments to render the\r\n   * RouteController's template plus all of the yieldTemplates.\r\n   *\r\n   */\r\n\r\n  render: function (template, options) {\r\n    var to;\r\n    var template;\r\n    var layout;\r\n    var self = this;\r\n\r\n    var addRenderedYield = function (key) {\r\n      if (self._renderedYields) {\r\n        key = key || '__main__';\r\n        self._renderedYields.push(key);\r\n      }\r\n    };\r\n\r\n    if (arguments.length == 0) {\r\n      this.router && this.router.setTemplate(this.template);\r\n      addRenderedYield();\r\n      \r\n      this.renderYields();\r\n    } else {\r\n      options = options || {};\r\n      to = options.to;\r\n      this.router && this.router.setTemplate(template, to);\r\n      addRenderedYield(to);\r\n    }\r\n  },\r\n  \r\n  // render all the templates \r\n  renderYields: function() {\r\n    var self = this;\r\n    \r\n    _.each(this.yieldTemplates, function (opts, tmpl) {\r\n      self.render(tmpl, opts)\r\n    });\r\n  },\r\n\r\n  setLayout: function (template) {\r\n    this.router && this.router.setLayout(template);\r\n  },\r\n\r\n  run: function () {\r\n    var self = this;\r\n    var args = _.toArray(arguments);\r\n    var action = _.isFunction(this.action) ? this.action : this[this.action];\r\n\r\n    Utils.assert(action,\r\n      \"You don't have an action named \\\"\" + this.action + \"\\\" defined on your RouteController\");\r\n\r\n    this.stopped = false;\r\n\r\n    this._renderedYields = [];\r\n\r\n    // when the waitlist status changes it will get cleared and then\r\n    // populated again from any before hooks or action functions. For\r\n    // subscriptions, we take advantage of the fact that Meteor won't subscribe\r\n    // again to the same subscription because of a computation rerun.\r\n    this._waitList.clear();\r\n\r\n    /*\r\n     * Each waitOn value could be an object, array or function. Because it's a\r\n     * concatenation of waitOn options from Router -> Route -> RouteController.\r\n     * So by the time we're done here we should just have a list of objects.\r\n     */\r\n    var waitOn = _.flatten(_.map(this.waitOn, function (fnOrHandle) {\r\n      return _.isFunction(fnOrHandle) ? fnOrHandle.call(self) : fnOrHandle;\r\n    }));\r\n\r\n    this._waitList.append(waitOn);\r\n\r\n    this.setLayout(this.layoutTemplate);\r\n\r\n    // Step 1: Run the before hooks\r\n    this.runHooks('before', [\r\n      autoRenderLoadingTemplateHook,\r\n      setDataHook,\r\n      autoRenderNotFoundTemplateHook,\r\n    ]);\r\n\r\n    if (this.stopped) {\r\n      this.isFirstRun = false;\r\n      return;\r\n    }\r\n\r\n    // Step 2: If we're not stopped, run the action\r\n    action.call(this);\r\n\r\n    // Step 3: Run the after hooks\r\n    this.runHooks('after', [\r\n      autoClearUnusedYieldsHook\r\n    ]);\r\n\r\n    // We've run at least once\r\n    this.isFirstRun = false;\r\n  },\r\n\r\n  wait: function (handle) {\r\n    handle = _.isFunction(handle) ? handle.call(this) : handle;\r\n    // handle could be an object or a array if a function returned an array\r\n    this._waitList.append(handle);\r\n  },\r\n\r\n  action: function () {\r\n    this.render();\r\n  }\r\n});\r\n","if (Handlebars) {\r\n  Handlebars.registerHelper('pathFor', function (routeName, params, options) {\r\n\r\n    if (arguments.length == 2) {\r\n      options = params;\r\n      params = this;\r\n    }\r\n\r\n    var hash = options.hash.hash;\r\n    var query = _.omit(options.hash, 'hash');\r\n\r\n    return Router.path(routeName, params, {\r\n      query: query,\r\n      hash: hash\r\n    });\r\n  });\r\n\r\n  Handlebars.registerHelper('urlFor', function (routeName, params, options) {\r\n    if (arguments.length == 2) {\r\n      options = params;\r\n      params = this;\r\n    }\r\n\r\n    var hash = options.hash.hash;\r\n    var query = _.omit(options.hash, 'hash');\r\n\r\n    return Router.url(routeName, params, {\r\n      query: query,\r\n      hash: hash\r\n    });\r\n  });\r\n\r\n  Handlebars.registerHelper('renderRouter', function (options) {\r\n    return new Handlebars.SafeString(Router.render());\r\n  });\r\n\r\n  Handlebars.registerHelper('currentRouteController', function () {\r\n    return Router.current();\r\n  });\r\n\r\n  Handlebars.registerHelper('link', function (options) {\r\n    var hash = options.hash || {};\r\n    var route = hash.route;\r\n    var params = hash.params || this;\r\n    var query = hash.query;\r\n    var urlHash = hash.hash;\r\n    var cls = hash['class'] || '';\r\n\r\n    var path = Router.path(route, params, {\r\n      query: query,\r\n      hash: urlHash\r\n    });\r\n\r\n    var html = '<a href=\"' + path + '\" class=\"' + cls + '\">';\r\n    html += options.fn(this);\r\n    html += '</a>'\r\n\r\n    return new Handlebars.SafeString(html);\r\n  });\r\n}\r\n"]}